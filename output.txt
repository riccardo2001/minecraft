package ui;

public class Menu {
    
}
package ui;

public class HUD {
    
}
package core;

import graphics.Render;
import scene.Scene;

public interface IAppLogic {

    void cleanup();

    void init(Window window, Scene scene, Render render);

    void input(Window window, Scene scene, float diffTimeMillis);

    void update(Window window, Scene scene, long diffTimeMillis);
}
package core;

import org.joml.Vector2f;
import org.lwjgl.BufferUtils;

import static org.lwjgl.glfw.GLFW.*;

import java.nio.DoubleBuffer;

public class MouseInput {
    private Vector2f currentPos, displVec, previousPos;
    private boolean leftButtonPressed, rightButtonPressed;

    public MouseInput(long windowHandle) {
        glfwSetInputMode(windowHandle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
        previousPos = new Vector2f(-1, -1);
        currentPos = new Vector2f();
        displVec = new Vector2f();
        glfwSetCursorPosCallback(windowHandle, (handle, xpos, ypos) -> {
            currentPos.x = (float) xpos;
            currentPos.y = (float) ypos;
        });
        glfwSetMouseButtonCallback(windowHandle, (handle, button, action, mode) -> {
            leftButtonPressed = button == GLFW_MOUSE_BUTTON_1 && action == GLFW_PRESS;
            rightButtonPressed = button == GLFW_MOUSE_BUTTON_2 && action == GLFW_PRESS;
        });
    }

    public Vector2f getCurrentPos() {
        return currentPos;
    }

    public Vector2f getDisplVec() {
        return displVec;
    }

    public void input(long windowHandle, boolean isPaused) {
        if (isPaused) {
            return; // Non catturare il movimento del mouse se in pausa
        }

        displVec.set(0, 0);

        DoubleBuffer xPosBuffer = BufferUtils.createDoubleBuffer(1);
        DoubleBuffer yPosBuffer = BufferUtils.createDoubleBuffer(1);
        glfwGetCursorPos(windowHandle, xPosBuffer, yPosBuffer);

        float newX = (float) xPosBuffer.get(0);
        float newY = (float) yPosBuffer.get(0);

        if (previousPos.x < 0 || previousPos.y < 0) {
            previousPos.set(newX, newY);
        }

        displVec.x = newX - previousPos.x;
        displVec.y = newY - previousPos.y;

        glfwSetCursorPos(windowHandle, 1280 / 2.0, 720 / 2.0);

        previousPos.set(1280 / 2.0f, 720 / 2.0f);
    }

    public boolean isLeftButtonPressed() {
        return leftButtonPressed;
    }

    public boolean isRightButtonPressed() {
        return rightButtonPressed;
    }
}
package core;

import org.lwjgl.glfw.GLFWVidMode;
import java.util.concurrent.Callable;

import static org.lwjgl.glfw.Callbacks.glfwFreeCallbacks;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.system.MemoryUtil.NULL;

public class Window {
    private final long windowHandle;
    private int width, height;
    private String title;
    private Callable<Void> resizeFunc;
    private MouseInput mouseInput;
    private boolean isCursorVisible = false;
    private boolean isPaused = false;

    public static class WindowOptions {
        public boolean compatibleProfile;
        public int fps;
        public int height;
        public int ups;
        public int width;
    }

    public Window(String title, WindowOptions opts, Callable<Void> resizeFunc) {
        this.resizeFunc = resizeFunc;
        if (!glfwInit()) {
            throw new IllegalStateException("Unable to initialize GLFW");
        }
        glfwDefaultWindowHints();
        glfwWindowHint(GLFW_VISIBLE, GL_FALSE);
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
        if (opts.compatibleProfile) {
            glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);
        } else {
            glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
            glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
        }
        if (opts.width > 0 && opts.height > 0) {
            width = opts.width;
            height = opts.height;
        } else {
            glfwWindowHint(GLFW_MAXIMIZED, GLFW_TRUE);
            GLFWVidMode vidMode = glfwGetVideoMode(glfwGetPrimaryMonitor());
            width = vidMode.width();
            height = vidMode.height();
        }
        windowHandle = glfwCreateWindow(width, height, title, NULL, NULL);
        if (windowHandle == NULL) {
            throw new RuntimeException("Failed to create GLFW window");
        }
        glfwSetFramebufferSizeCallback(windowHandle, (window, w, h) -> resized(w, h));

        // Gestione del tasto ESC per alternare la visibilità del cursore e la pausa
        glfwSetKeyCallback(windowHandle, (window, key, scancode, action, mods) -> {
            if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {
                togglePause();
            }
        });

        glfwMakeContextCurrent(windowHandle);
        if (opts.fps > 0) {
            glfwSwapInterval(0);
        } else {
            glfwSwapInterval(1);
        }
        glfwShowWindow(windowHandle);

        int[] wArr = new int[1], hArr = new int[1];
        glfwGetFramebufferSize(windowHandle, wArr, hArr);
        width = wArr[0];
        height = hArr[0];

        mouseInput = new MouseInput(windowHandle);
    }

    private void togglePause() {
        isPaused = !isPaused;
        if (isPaused) {
            glfwSetInputMode(windowHandle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);

            isCursorVisible = true;
        } else {
            glfwSetInputMode(windowHandle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
            isCursorVisible = false;
        }
    }

    protected void resized(int w, int h) {
        width = w;
        height = h;
        try {
            resizeFunc.call();
        } catch (Exception e) {
        }
    }

    public void pollEvents() {
        glfwPollEvents();
    }

    public void update() {
        renderPauseOverlay();
        glfwSwapBuffers(windowHandle);
    }

    public boolean windowShouldClose() {
        return glfwWindowShouldClose(windowHandle);
    }

    public MouseInput getMouseInput() {
        return mouseInput;
    }

    public boolean isKeyPressed(int keyCode) {
        return glfwGetKey(windowHandle, keyCode) == GLFW_PRESS;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public long getWindowHandle() {
        return windowHandle;
    }

    public void setTitle(String title) {
        this.title = title;
        glfwSetWindowTitle(windowHandle, title);
    }

    public void cleanup() {
        glfwFreeCallbacks(windowHandle);
        glfwDestroyWindow(windowHandle);
        glfwTerminate();
    }

    public String getTitle() {
        return title;
    }

    public void renderPauseOverlay() {
        if (isPaused) {
            glClearColor(0.3f, 0.3f, 0.3f, 0.7f);
            glClear(GL_COLOR_BUFFER_BIT);
        } else {
            glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
        }
    }

    public boolean isCursorVisible() {
        return isCursorVisible;
    }
}
package core;

public class Timer {
    
}
package core;

import graphics.Render;
import scene.Scene;

public class Engine {
    public static final int TARGET_UPS = 30;
    private final IAppLogic appLogic;
    private final Window window;
    private final Render render;
    private final Scene scene;
    private boolean running;
    private int targetFps;
    private int targetUps;

    public Engine(String windowTitle, Window.WindowOptions opts, IAppLogic appLogic) {
        window = new Window(windowTitle, opts, () -> {
            resize();
            return null;
        });
        targetFps = opts.fps;
        targetUps = opts.ups;
        render = new Render();
        scene = new Scene(window.getWidth(), window.getHeight());
        this.appLogic = appLogic;
        this.appLogic.init(window, scene, render);
        running = true;
    }

    private void cleanup() {
        appLogic.cleanup();
        window.cleanup();
        render.cleanup();
        scene.cleanup();
    }

    private void resize() {
        scene.resize(window.getWidth(), window.getHeight());
    }

    private void run() {
        final double nsPerUpdate = 1e9 / targetUps;
        final double nsPerFrame = targetFps > 0 ? 1e9 / targetFps : 0;
        
        long lastTime = System.nanoTime();
        long lastUpdateTime = lastTime;
        long lastFrameTime = lastTime;
        int frames = 0;
        long fpsTimer = lastTime;

        while (running && !window.windowShouldClose()) {
            window.pollEvents();
            long now = System.nanoTime();

            if (now - lastUpdateTime >= nsPerUpdate) {
                long updateDiffMillis = (now - lastUpdateTime) / 1_000_000L;
                appLogic.update(window, scene, updateDiffMillis);
                lastUpdateTime = now;
            }

            if (targetFps <= 0 || now - lastFrameTime >= nsPerFrame) {
                long frameDiffMillis = (now - lastFrameTime) / 1_000_000L;
                appLogic.input(window, scene, (float) frameDiffMillis);
                render.render(window, scene);
                window.update();
                frames++;
                lastFrameTime = now;
            }

            if (now - fpsTimer >= 1e9) {
                window.setTitle("Minecraft | FPS: " + frames);
                frames = 0;
                fpsTimer = now;
            }

            lastTime = now;
        }
        cleanup();
    }

    public void start() {
        running = true;
        run();
    }

    public void stop() {
        running = false;
    }
}package core;

import graphics.Render;
import scene.Camera;
import scene.Scene;
import world.World;
import org.joml.Vector2f;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;


public class Main implements IAppLogic {
    private static final float MOUSE_SENSITIVITY = 0.1f;
    private static final float MOVEMENT_SPEED = 0.005f;

    public static void main(String[] args) {
        Main main = new Main();
        Window.WindowOptions opts = new Window.WindowOptions();
        opts.width = 1280;
        opts.height = 720;
        opts.fps = 1000;
        opts.ups = Engine.TARGET_UPS;
        opts.compatibleProfile = false;
        Engine gameEng = new Engine("Minecraft", opts, main);
        gameEng.start();
    }

    @Override
    public void cleanup() {
        // Cleanup eventuale
    }

    @Override
    public void init(Window window, Scene scene, Render render) {
        scene.setWorld(new World());
        scene.getWorld().generateInitialWorld(0, 0);
        scene.getCamera().setPosition(0f, 75f, 0f);
        System.out.println("World generated");

        System.out.println("OpenGL Vendor: " + glGetString(GL_VENDOR));
        System.out.println("OpenGL Renderer: " + glGetString(GL_RENDERER));
        System.out.println("OpenGL Version: " + glGetString(GL_VERSION));

    }

    @Override
    public void input(Window window, Scene scene, float diffTimeMillis) {
        boolean isPaused = window.isCursorVisible();

        if (!isPaused) {
            window.getMouseInput().input(window.getWindowHandle(), false); 
        }

        float move = diffTimeMillis * MOVEMENT_SPEED;
        Camera camera = scene.getCamera();
        MouseInput mouseInput = window.getMouseInput();
        Vector2f displVec = mouseInput.getDisplVec();

        if (!isPaused) {
            if (window.isKeyPressed(GLFW_KEY_W)) {
                camera.moveForward(move);
            } else if (window.isKeyPressed(GLFW_KEY_S)) {
                camera.moveBackwards(move);
            }
            if (window.isKeyPressed(GLFW_KEY_A)) {
                camera.moveLeft(move);
            } else if (window.isKeyPressed(GLFW_KEY_D)) {
                camera.moveRight(move);
            }
            if (window.isKeyPressed(GLFW_KEY_SPACE)) {
                camera.moveUp(move);
            } else if (window.isKeyPressed(GLFW_KEY_LEFT_CONTROL)) {
                camera.moveDown(move);
            }

            camera.addRotation(
                    (float) Math.toRadians(displVec.x * MOUSE_SENSITIVITY),
                    (float) Math.toRadians(displVec.y * MOUSE_SENSITIVITY));
        }
    }

    @Override
    public void update(Window window, Scene scene, long diffTimeMillis) {
        float playerX = scene.getCamera().getPosition().x;
        float playerZ = scene.getCamera().getPosition().z;
        scene.updateWorldGeneration(playerX, playerZ);
    }
}package core;

public class Settings {
    
}
package world;

import java.util.Objects;

public class ChunkPosition {
    int x, z;

    public ChunkPosition(int x, int z) {
        this.x = x;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        ChunkPosition that = (ChunkPosition) o;
        return x == that.x && z == that.z;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, z);
    }


    public int getX() {
        return this.x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getZ() {
        return this.z;
    }

    public void setZ(int z) {
        this.z = z;
    }

}
package world;

import java.util.HashMap;
import java.util.Map;

public class World {
    private Map<ChunkPosition, Chunk> loadedChunks;
    private int renderDistance = 4;

    public World() {
        this.loadedChunks = new HashMap<>();
    }

    public void generateInitialWorld(float centerX, float centerZ) {
        int centerChunkX = (int) Math.floor(centerX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int centerChunkZ = (int) Math.floor(centerZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        System.out.println("Generazione mondo iniziale intorno al chunk centrale: " + centerChunkX + "," + centerChunkZ);

        for (int dx = -renderDistance; dx <= renderDistance; dx++) {
            for (int dz = -renderDistance; dz <= renderDistance; dz++) {
                int chunkX = centerChunkX + dx;
                int chunkZ = centerChunkZ + dz;

                ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);

                if (!loadedChunks.containsKey(chunkPos)) {
                    Chunk chunk = new Chunk(chunkX, chunkZ);
                    System.out.println("Generato nuovo chunk in posizione " + chunkX + "," + chunkZ + " (hash: " + chunk.hashCode() + ")");
                    loadedChunks.put(chunkPos, chunk);
                }
            }
        }
    }

    public void setBlockAtWorldPosition(float worldX, float worldY, float worldZ, Block.BlockType blockType) {
        // Calcola le coordinate del chunk
        int chunkX = (int) Math.floor(worldX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int chunkZ = (int) Math.floor(worldZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        // Calcola le coordinate locali all'interno del chunk
        int localX = (int) Math.floor((worldX % (Chunk.WIDTH * Block.BLOCK_SIZE)) / Block.BLOCK_SIZE);
        int localY = (int) Math.floor(worldY / Block.BLOCK_SIZE);
        int localZ = (int) Math.floor((worldZ % (Chunk.DEPTH * Block.BLOCK_SIZE)) / Block.BLOCK_SIZE);
        
        // Correggi le coordinate negative
        if (worldX < 0 && localX == 0) {
            chunkX--;
            localX = Chunk.WIDTH - 1;
        }
        if (worldZ < 0 && localZ == 0) {
            chunkZ--;
            localZ = Chunk.DEPTH - 1;
        }

        ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);
        Chunk chunk = loadedChunks.get(chunkPos);

        if (chunk != null) {
            // Crea un nuovo blocco senza entità
            Block newBlock = new Block(blockType);
            chunk.setBlock(localX, localY, localZ, newBlock);
            
            // Segna il chunk come modificato (dirty) per ricostruire la mesh
            // Questo è già fatto implicitamente nel metodo setBlock di Chunk
            
            // Segna anche i chunk adiacenti come dirty se il blocco è sul bordo
            // perché la visibilità delle facce può cambiare
            updateAdjacentChunksIfNeeded(chunkX, chunkZ, localX, localY, localZ);
        }
    }
    
    private void updateAdjacentChunksIfNeeded(int chunkX, int chunkZ, int localX, int localY, int localZ) {
        // Verifica se il blocco è sul bordo del chunk e aggiorna i chunk adiacenti
        if (localX == 0) {
            Chunk adjacentChunk = getChunk(chunkX - 1, chunkZ);
            if (adjacentChunk != null) {
                adjacentChunk.resetDirtyFlag(); // Forza il rebuild della mesh
            }
        }
        if (localX == Chunk.WIDTH - 1) {
            Chunk adjacentChunk = getChunk(chunkX + 1, chunkZ);
            if (adjacentChunk != null) {
                adjacentChunk.resetDirtyFlag(); // Forza il rebuild della mesh
            }
        }
        if (localZ == 0) {
            Chunk adjacentChunk = getChunk(chunkX, chunkZ - 1);
            if (adjacentChunk != null) {
                adjacentChunk.resetDirtyFlag(); // Forza il rebuild della mesh
            }
        }
        if (localZ == Chunk.DEPTH - 1) {
            Chunk adjacentChunk = getChunk(chunkX, chunkZ + 1);
            if (adjacentChunk != null) {
                adjacentChunk.resetDirtyFlag(); // Forza il rebuild della mesh
            }
        }
    }

    public Map<ChunkPosition, Chunk> getLoadedChunks() {
        return loadedChunks;
    }

    public Block getBlock(int x, int y, int z) {
        // Trova il chunk che contiene queste coordinate
        int chunkX = Math.floorDiv(x, Chunk.WIDTH);
        int chunkZ = Math.floorDiv(z, Chunk.DEPTH);

        Chunk chunk = getChunk(chunkX, chunkZ);
        if (chunk == null) {
            return null;
        }

        // Trova il blocco all'interno del chunk
        int localX = Math.floorMod(x, Chunk.WIDTH);
        int localZ = Math.floorMod(z, Chunk.DEPTH);
        
        return chunk.getBlock(localX, y, localZ);
    }

    public Chunk getChunk(int chunkX, int chunkZ) {
        ChunkPosition position = new ChunkPosition(chunkX, chunkZ);
        return loadedChunks.get(position);
    }

    public int getRenderDistance() {
        return renderDistance;
    }
}package world;

import java.util.ArrayList;
import java.util.List;
import graphics.Mesh;
import org.joml.Vector4f;
import scene.Scene;

public class ChunkMesh {
    
    private Mesh mesh;
    
    public Mesh getMesh() {
        return mesh;
    }
    
    public void buildMesh(Chunk chunk, World world) {
        // Elenchi per memorizzare i dati della mesh
        List<Float> positions = new ArrayList<>();
        List<Float> textureCoords = new ArrayList<>();
        List<Integer> indices = new ArrayList<>();
        
        int indexCount = 0;
        
        // Per ogni blocco nel chunk
        for (int x = 0; x < Chunk.WIDTH; x++) {
            for (int y = 0; y < Chunk.HEIGHT; y++) {
                for (int z = 0; z < Chunk.DEPTH; z++) {
                    Block block = chunk.getBlock(x, y, z);
                    
                    if (block != null && block.getType() != Block.BlockType.AIR) {
                        // Calcola la posizione mondiale del blocco
                        int worldX = chunk.getChunkX() * Chunk.WIDTH + x;
                        int worldY = y;
                        int worldZ = chunk.getChunkZ() * Chunk.DEPTH + z;
                        
                        // Per ogni faccia del blocco
                        for (Block.Face face : Block.Face.values()) {
                            // Controlla se la faccia deve essere renderizzata
                            if (Block.shouldRenderFace(world, worldX, worldY, worldZ, face)) {
                                // Aggiungi la faccia alla mesh
                                indexCount = addFaceToMesh(
                                    positions, textureCoords, indices, 
                                    x, y, z, indexCount, face, block.getType()
                                );
                            }
                        }
                    }
                }
            }
        }
        
        // Converte le liste in array
        float[] posArray = new float[positions.size()];
        float[] texArray = new float[textureCoords.size()];
        int[] indArray = new int[indices.size()];
        
        for (int i = 0; i < positions.size(); i++) {
            posArray[i] = positions.get(i);
        }
        
        for (int i = 0; i < textureCoords.size(); i++) {
            texArray[i] = textureCoords.get(i);
        }
        
        for (int i = 0; i < indices.size(); i++) {
            indArray[i] = indices.get(i);
        }
        
        // Pulisce la vecchia mesh se esiste
        if (mesh != null) {
            mesh.cleanup();
        }
        
        // Crea la nuova mesh (anche se vuota)
        mesh = new Mesh(posArray, texArray, indArray);
    }
    
    private int addFaceToMesh(
            List<Float> positions, List<Float> textureCoords, List<Integer> indices,
            int x, int y, int z, int indexStart, Block.Face face, Block.BlockType blockType) {
        
        float blockSize = Block.BLOCK_SIZE;
        
        // Calcola le coordinate dei vertici in base alla faccia
        float x1 = x * blockSize;
        float y1 = y * blockSize;
        float z1 = z * blockSize;
        float x2 = x1 + blockSize;
        float y2 = y1 + blockSize;
        float z2 = z1 + blockSize;
        
        switch (face) {
            case TOP:
                positions.add(x1); positions.add(y2); positions.add(z1);
                positions.add(x1); positions.add(y2); positions.add(z2);
                positions.add(x2); positions.add(y2); positions.add(z2);
                positions.add(x2); positions.add(y2); positions.add(z1);
                break;
            case BOTTOM:
                positions.add(x1); positions.add(y1); positions.add(z1);
                positions.add(x2); positions.add(y1); positions.add(z1);
                positions.add(x2); positions.add(y1); positions.add(z2);
                positions.add(x1); positions.add(y1); positions.add(z2);
                break;
            case FRONT:
                positions.add(x1); positions.add(y1); positions.add(z2);
                positions.add(x2); positions.add(y1); positions.add(z2);
                positions.add(x2); positions.add(y2); positions.add(z2);
                positions.add(x1); positions.add(y2); positions.add(z2);
                break;
            case BACK:
                positions.add(x1); positions.add(y1); positions.add(z1);
                positions.add(x1); positions.add(y2); positions.add(z1);
                positions.add(x2); positions.add(y2); positions.add(z1);
                positions.add(x2); positions.add(y1); positions.add(z1);
                break;
            case RIGHT:
                positions.add(x2); positions.add(y1); positions.add(z1);
                positions.add(x2); positions.add(y2); positions.add(z1);
                positions.add(x2); positions.add(y2); positions.add(z2);
                positions.add(x2); positions.add(y1); positions.add(z2);
                break;
            case LEFT:
                positions.add(x1); positions.add(y1); positions.add(z1);
                positions.add(x1); positions.add(y1); positions.add(z2);
                positions.add(x1); positions.add(y2); positions.add(z2);
                positions.add(x1); positions.add(y2); positions.add(z1);
                break;
        }
        
        Vector4f textureRegion = getTextureRegion(blockType, face);
        addTextureCoords(textureCoords, textureRegion, face);
        
        indices.add(indexStart);
        indices.add(indexStart + 1);
        indices.add(indexStart + 2);
        indices.add(indexStart);
        indices.add(indexStart + 2);
        indices.add(indexStart + 3);
        
        return indexStart + 4;
    }
    
    private void addTextureCoords(List<Float> textureCoords, Vector4f region, Block.Face face) {
        // Coordinate texture (U,V) per ogni vertice della faccia
        float minU = region.x;
        float minV = region.y;
        float maxU = region.z;
        float maxV = region.w;
        
        switch (face) {
            case FRONT:
                textureCoords.add(minU); textureCoords.add(maxV); // In basso a sinistra
                textureCoords.add(maxU); textureCoords.add(maxV); // In basso a destra
                textureCoords.add(maxU); textureCoords.add(minV); // In alto a destra
                textureCoords.add(minU); textureCoords.add(minV); // In alto a sinistra
                break;
            case BACK:
                textureCoords.add(minU); textureCoords.add(maxV); // In basso a sinistra
                textureCoords.add(minU); textureCoords.add(minV); // In alto a sinistra
                textureCoords.add(maxU); textureCoords.add(minV); // In alto a destra
                textureCoords.add(maxU); textureCoords.add(maxV); // In basso a destra
                break;
            case LEFT:
                textureCoords.add(maxU); textureCoords.add(maxV); // In basso a sinistra
                textureCoords.add(minU); textureCoords.add(maxV); // In basso a destra
                textureCoords.add(minU); textureCoords.add(minV); // In alto a destra
                textureCoords.add(maxU); textureCoords.add(minV); // In alto a sinistra
                break;
            case RIGHT:
                textureCoords.add(minU); textureCoords.add(maxV); // In basso a sinistra
                textureCoords.add(minU); textureCoords.add(minV); // In alto a sinistra
                textureCoords.add(maxU); textureCoords.add(minV); // In alto a destra
                textureCoords.add(maxU); textureCoords.add(maxV); // In basso a destra
                break;
            case TOP:
                textureCoords.add(minU); textureCoords.add(maxV); // In basso a sinistra
                textureCoords.add(minU); textureCoords.add(minV); // In alto a sinistra
                textureCoords.add(maxU); textureCoords.add(minV); // In alto a destra
                textureCoords.add(maxU); textureCoords.add(maxV); // In basso a destra
                break;
            case BOTTOM:
                textureCoords.add(minU); textureCoords.add(maxV); // In basso a sinistra
                textureCoords.add(maxU); textureCoords.add(maxV); // In basso a destra
                textureCoords.add(maxU); textureCoords.add(minV); // In alto a destra
                textureCoords.add(minU); textureCoords.add(minV); // In alto a sinistra
                break;
        }
    }
    
    private Vector4f getTextureRegion(Block.BlockType blockType, Block.Face face) {
        return Scene.getBlockTextureRegion(blockType, face);
    }
}
package world;

import scene.Entity;
import scene.Scene;
import org.joml.Vector4f;
import java.util.Random;

public class Chunk {
    public static final int WIDTH = 16;
    public static final int HEIGHT = 256;
    public static final int DEPTH = 16;

    private final int chunkX;
    private final int chunkZ;
    private Block[][][] blocks;
    private boolean isDirty;
    private ChunkMesh chunkMesh;
    private Entity chunkEntity;
    private Random random;

    private static final int BASE_HEIGHT = 64;
    // Seed statico per garantire coerenza tra diverse esecuzioni
    private static final long WORLD_SEED = 42L;

    public Chunk(int chunkX, int chunkZ) {
        this.chunkX = chunkX;
        this.chunkZ = chunkZ;
        this.blocks = new Block[WIDTH][HEIGHT][DEPTH];
        this.isDirty = true;
        
        // Crea un seed unico per questo chunk basato sulla sua posizione
        long chunkSeed = WORLD_SEED ^ ((long)chunkX << 32) ^ chunkZ;
        this.random = new Random(chunkSeed);

        generateInitialTerrain();
    }

    private void generateInitialTerrain() {
        int[][] heightMap = generateHeightMap();

        for (int x = 0; x < WIDTH; x++) {
            for (int z = 0; z < DEPTH; z++) {
                int terrainHeight = heightMap[x][z];

                for (int y = 0; y < HEIGHT; y++) {
                    Block.BlockType blockType;

                    blockType = determineBlockType(x, y, z, terrainHeight);

                    if (blockType != Block.BlockType.AIR) {
                        Block block = new Block(blockType);
                        setBlock(x, y, z, block);
                    }
                }
            }
        }

        generateTrees(heightMap);
    }

    private int[][] generateHeightMap() {
        int[][] heightMap = new int[WIDTH][DEPTH];

        // Terreno piatto con altezza costante
        for (int x = 0; x < WIDTH; x++) {
            for (int z = 0; z < DEPTH; z++) {
                heightMap[x][z] = BASE_HEIGHT;
            }
        }

        return heightMap;
    }

    private void generateTrees(int[][] heightMap) {
        // Crea un seed deterministico per gli alberi di questo chunk
        long treeSeed = WORLD_SEED ^ ((long)chunkX * 73856093L) ^ ((long)chunkZ * 19349663L);
        Random treeRandom = new Random(treeSeed);
        
        System.out.println("Seed per alberi nel chunk " + chunkX + "," + chunkZ + ": " + treeSeed);

        int maxTrees = 5;
        int numTrees = treeRandom.nextInt(maxTrees + 1);

        numTrees += (int) (Math.abs(Math.sin((chunkX * 12.9898 + chunkZ * 78.233) * 0.1)) * 2);
        numTrees = Math.min(numTrees, 8);

        System.out.println("Tentativo di generare " + numTrees + " alberi nel chunk " + chunkX + "," + chunkZ);

        int alberiGenerati = 0;
        int tentativi = 0;
        int maxTentativi = 30;

        boolean[][] positionTried = new boolean[WIDTH][DEPTH];

        while (alberiGenerati < numTrees && tentativi < maxTentativi) {
            tentativi++;

            int treeX, treeZ;
            do {
                treeX = 3 + treeRandom.nextInt(WIDTH - 6);
                treeZ = 3 + treeRandom.nextInt(DEPTH - 6);
            } while (positionTried[treeX][treeZ]);

            positionTried[treeX][treeZ] = true;

            int terrainHeight = heightMap[treeX][treeZ];

            Block block = getBlock(treeX, terrainHeight - 1, treeZ);
            if (block != null && block.getType() == Block.BlockType.GRASS) {
                if (terrainHeight + 11 < HEIGHT && hasEnoughSpace(treeX, terrainHeight, treeZ)) {
                    // Usa treeRandom per determinare il tipo di albero
                    generateTree(treeX, terrainHeight, treeZ, treeRandom.nextInt(3));
                    alberiGenerati++;
                }
            }
        }

        System.out.println("Generati " + alberiGenerati + " alberi nel chunk " + chunkX + "," + chunkZ);
    }

    private boolean hasEnoughSpace(int x, int y, int z) {
        for (int dx = -2; dx <= 2; dx++) {
            for (int dz = -2; dz <= 2; dz++) {
                int checkX = x + dx;
                int checkZ = z + dz;
                if (isValidPosition(checkX, y, checkZ)) {
                    Block block = getBlock(checkX, y, checkZ);
                    if (block != null && block.getType() == Block.BlockType.WOOD) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    private void generateTree(int x, int y, int z, int treeType) {
        if (!isValidPosition(x, y, z) || !isTreeAreaValid(x, y, z)) {
            return;
        }

        // Crea un random specifico per questo albero basato sulla sua posizione nel mondo
        long treePosX = chunkX * WIDTH + x;
        long treePosZ = chunkZ * DEPTH + z;
        Random treeRandom = new Random(WORLD_SEED ^ ((treePosX << 16) ^ treePosZ));
        
        int trunkHeight;
        int leafSize;

        switch (treeType) {
            case 0:
                trunkHeight = 4 + treeRandom.nextInt(2);
                leafSize = 1;
                break;
            case 1:
                trunkHeight = 5 + treeRandom.nextInt(2);
                leafSize = 2;
                break;
            case 2:
            default:
                trunkHeight = 6 + treeRandom.nextInt(2);
                leafSize = 2;
                break;
        }

        // Genera il tronco
        for (int i = 0; i < trunkHeight; i++) {
            setBlock(x, y + i, z, new Block(Block.BlockType.WOOD));
        }

        // Usa il treeRandom anche per generare le foglie
        generateLeaves(x, y + trunkHeight - 2, z, leafSize, treeType, treeRandom);

        setBlock(x, y + trunkHeight, z, new Block(Block.BlockType.LEAVES));
        if (treeType == 2 && y + trunkHeight + 1 < HEIGHT) {
            setBlock(x, y + trunkHeight + 1, z, new Block(Block.BlockType.LEAVES));
        }
    }

    private boolean isTreeAreaValid(int x, int y, int z) {
        int leafSize = 3;
        if (x - leafSize < 0 || x + leafSize >= WIDTH ||
                z - leafSize < 0 || z + leafSize >= DEPTH ||
                y + 10 >= HEIGHT) {
            return false;
        }
        return true;
    }

    private void generateLeaves(int x, int y, int z, int leafSize, int treeType, Random treeRandom) {
        for (int dx = -leafSize - 1; dx <= leafSize + 1; dx++) {
            for (int dz = -leafSize - 1; dz <= leafSize + 1; dz++) {
                int maxDistance = Math.abs(dx) + Math.abs(dz);
                int leafHeight = treeType == 2 ? 4 : 3;

                for (int dy = 0; dy < leafHeight; dy++) {
                    boolean shouldPlace = false;

                    if (treeType == 0) {
                        shouldPlace = maxDistance <= leafSize + 1;
                    } else if (treeType == 1) {
                        shouldPlace = (maxDistance <= leafSize + 1) &&
                                !(Math.abs(dx) == leafSize + 1 && Math.abs(dz) == leafSize + 1);
                    } else {
                        shouldPlace = (maxDistance <= leafSize + 1) &&
                                !((Math.abs(dx) == leafSize + 1 && Math.abs(dz) == leafSize + 1) && dy != 1);

                        if (!shouldPlace && treeRandom.nextDouble() < 0.2 && maxDistance <= leafSize + 2) {
                            shouldPlace = true;
                        }
                    }

                    if (shouldPlace) {
                        int leafX = x + dx;
                        int leafY = y + dy;
                        int leafZ = z + dz;

                        if (isValidPosition(leafX, leafY, leafZ)) {
                            // Non sostituire il tronco con le foglie
                            if (!(dx == 0 && dz == 0 && dy == 0)) {
                                Block existingBlock = getBlock(leafX, leafY, leafZ);
                                if (existingBlock == null || existingBlock.getType() == Block.BlockType.AIR) {
                                    // Variazione casuale per rendere la chioma meno regolare
                                    if (treeRandom.nextDouble() > 0.1 || maxDistance <= leafSize) {
                                        setBlock(leafX, leafY, leafZ, new Block(Block.BlockType.LEAVES));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private Block.BlockType determineBlockType(int x, int y, int z, int terrainHeight) {
        if (y == 0)
            return Block.BlockType.STONE;
        if (y < terrainHeight - 1)
            return Block.BlockType.DIRT;
        if (y < terrainHeight)
            return Block.BlockType.GRASS;
        return Block.BlockType.AIR;
    }

    public void setBlock(int x, int y, int z, Block block) {
        if (isValidPosition(x, y, z)) {
            blocks[x][y][z] = block;
            isDirty = true;
        }
    }

    public Block getBlock(int x, int y, int z) {
        return isValidPosition(x, y, z) ? blocks[x][y][z] : null;
    }

    private boolean isValidPosition(int x, int y, int z) {
        return x >= 0 && x < WIDTH &&
                y >= 0 && y < HEIGHT &&
                z >= 0 && z < DEPTH;
    }

    public boolean isDirty() {
        return isDirty;
    }

    public void resetDirtyFlag() {
        isDirty = false;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkZ() {
        return chunkZ;
    }

    public Block[][][] getBlocks() {
        return blocks;
    }

    public void buildMesh(World world, Scene scene) {
        if (chunkMesh == null) {
            chunkMesh = new ChunkMesh();
        }

        chunkMesh.buildMesh(this, world);

        if (chunkEntity == null) {
            // Crea un'entità per il chunk
            String entityId = "chunk_" + chunkX + "_" + chunkZ;
            chunkEntity = new Entity(entityId, "chunk", new Vector4f(0, 0, 1, 1));
            chunkEntity.setPosition(
                    chunkX * WIDTH * Block.BLOCK_SIZE,
                    0,
                    chunkZ * DEPTH * Block.BLOCK_SIZE);
            chunkEntity.updateModelMatrix();

            // Aggiungi l'entità al model
            if (scene != null) {
                if (!scene.getModelMap().containsKey("chunk")) {
                    scene.registerChunkModel(chunkMesh.getMesh());
                }
                scene.addChunkEntity(chunkEntity);
            }
        } else if (scene != null) {
            // Aggiorna la mesh esistente
            scene.updateChunkMesh(chunkEntity.getId(), chunkMesh.getMesh());
        }

        resetDirtyFlag();
    }

    public Entity getChunkEntity() {
        return chunkEntity;
    }
}package world;

import org.joml.Vector3f;

import scene.Camera;
import scene.Scene;

public class Block {
    public static final float BLOCK_SIZE = 1.0f;
    private BlockType type;

    public enum BlockType {
        AIR,
        GRASS,
        DIRT,
        STONE,
        WOOD,
        LEAVES
    }

    public enum Face {
        TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT
    }

    public Block(BlockType type) {
        this.type = type;
    }

    public BlockType getType() {
        return type;
    }

    public boolean isSolid() {
        return type != BlockType.AIR;
    }

    public boolean isOpaque() {
        // Le foglie non sono completamente opache, così si possono vedere altre foglie
        return type != BlockType.AIR && type != BlockType.LEAVES;
    }
    
    /**
     * Verifica se una faccia del blocco dovrebbe essere renderizzata controllando se è adiacente a un blocco opaco
     */
    public static boolean shouldRenderFace(World world, int x, int y, int z, Face face) {
        int checkX = x;
        int checkY = y;
        int checkZ = z;
        
        switch (face) {
            case TOP: checkY = y + 1; break;
            case BOTTOM: checkY = y - 1; break;
            case FRONT: checkZ = z + 1; break;
            case BACK: checkZ = z - 1; break;
            case RIGHT: checkX = x + 1; break;
            case LEFT: checkX = x - 1; break;
        }
        
        Block adjacentBlock = world.getBlock(checkX, checkY, checkZ);
        return adjacentBlock == null || !adjacentBlock.isOpaque();
    }
    
    public static boolean isChunkVisible(Scene scene, Chunk chunk) {
        Camera camera = scene.getCamera();

        // Ottieni le coordinate del chunk
        float chunkMinX = chunk.getChunkX() * Chunk.WIDTH * BLOCK_SIZE;
        float chunkMinY = 0;
        float chunkMinZ = chunk.getChunkZ() * Chunk.DEPTH * BLOCK_SIZE;
        float chunkMaxX = (chunk.getChunkX() + 1) * Chunk.WIDTH * BLOCK_SIZE;
        float chunkMaxY = Chunk.HEIGHT * BLOCK_SIZE;
        float chunkMaxZ = (chunk.getChunkZ() + 1) * Chunk.DEPTH * BLOCK_SIZE;
        
        var chunkMin = new org.joml.Vector3f(chunkMinX, chunkMinY, chunkMinZ);
        var chunkMax = new org.joml.Vector3f(chunkMaxX, chunkMaxY, chunkMaxZ);

        // 1. Frustum Culling - verifica se il chunk è nel campo visivo della camera
        if (!camera.getFrustum().isBoxInFrustum(chunkMin, chunkMax)) {
            return false;
        }

        // 2. Distance Culling - ignora chunk troppo lontani
        float maxRenderDistanceSquared = 256.0f * 256.0f;  // 16 chunk di distanza al quadrato
        Vector3f cameraPos = camera.getPosition();
        Vector3f chunkCenterPos = new Vector3f(
            chunkMinX + (chunkMaxX - chunkMinX) / 2,
            chunkMinY + (chunkMaxY - chunkMinY) / 2,
            chunkMinZ + (chunkMaxZ - chunkMinZ) / 2
        );
        
        float distSquared = cameraPos.distanceSquared(chunkCenterPos);
        if (distSquared > maxRenderDistanceSquared) {
            return false;
        }

        return true;
    }
}
package utils;

import java.io.*;
import core.Main;

public class Utils {
    public static String readFile(String filePath) {
        try {
            InputStream in = Main.class.getClassLoader().getResourceAsStream(filePath);
            if (in == null) {
                in = new FileInputStream(filePath);
            }
            String content = new String(in.readAllBytes());
            in.close();
            return content;
        } catch (IOException e) {
            throw new RuntimeException("Error reading file: " + filePath, e);
        }
    }
}package audio;

public class SoundManager {
    
}
package physics;

public class Gravity {
    
}
package physics;

public class Collision {
    
}
package scene;

import java.util.*;
import core.Window;
import graphics.Mesh;
import graphics.Model;
import graphics.ShaderProgram;
import graphics.TextureAtlas;
import graphics.TextureCacheAtlas;
import graphics.UniformsMap;
import world.Block;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL13.*;
import static org.lwjgl.opengl.GL20.*;
import static org.lwjgl.opengl.GL30.*;

public class SceneRender {
    private ShaderProgram shaderProgram;
    private UniformsMap uniformsMap;

    public SceneRender() {
        List<ShaderProgram.ShaderModuleData> modules = new ArrayList<>();
        modules.add(new ShaderProgram.ShaderModuleData("shaders/scene.vert", GL_VERTEX_SHADER));
        modules.add(new ShaderProgram.ShaderModuleData("shaders/scene.frag", GL_FRAGMENT_SHADER));
        shaderProgram = new ShaderProgram(modules);
        createUniforms();
    }

    public void cleanup() {
        shaderProgram.cleanup();
    }

    public void render(Window window, Scene scene) {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glViewport(0, 0, window.getWidth(), window.getHeight());

        scene.getCamera().getFrustum().update(scene.getCamera().getViewMatrix(), scene.getProjection().getProjMatrix());

        shaderProgram.bind();
        uniformsMap.setUniform("projectionMatrix", scene.getProjection().getProjMatrix());
        uniformsMap.setUniform("viewMatrix", scene.getCamera().getViewMatrix());
        uniformsMap.setUniform("txtSampler", 0);

        TextureCacheAtlas textureCache = scene.getTextureCacheAtlas();
        TextureAtlas textureAtlas = textureCache.getAtlasTexture();
        glActiveTexture(GL_TEXTURE0);
        textureAtlas.bind();

        // Rendi tutti i chunk visibili
        var loadedChunks = scene.getWorld().getLoadedChunks();
        
        Model chunkModel = scene.getModelMap().get("chunk");
        if (chunkModel != null) {
            for (var entry : loadedChunks.entrySet()) {
                var chunk = entry.getValue();
                
                if (!Block.isChunkVisible(scene, chunk)) {
                    continue;
                }
                
                // Se il chunk è stato modificato, costruisci la sua mesh
                if (chunk.isDirty()) {
                    chunk.buildMesh(scene.getWorld(), scene);
                }
                
                // Ottieni l'entità del chunk
                Entity chunkEntity = chunk.getChunkEntity();
                if (chunkEntity != null) {
                    // Renderizza l'entità del chunk
                    for (Mesh mesh : chunkModel.getMeshList()) {
                        glBindVertexArray(mesh.getVaoId());
                        
                        chunkEntity.updateModelMatrix();
                        uniformsMap.setUniform("modelMatrix", chunkEntity.getModelMatrix());
                        glDrawElements(GL_TRIANGLES, mesh.getNumVertices(), GL_UNSIGNED_INT, 0);
                        
                        glBindVertexArray(0);
                    }
                }
            }
        }

        // Renderizza eventuali altre entità non relative ai chunk
        renderOtherEntities(scene);

        shaderProgram.unbind();
    }
    
    private void renderOtherEntities(Scene scene) {
        // Mappa modelli -> entità per le entità che non sono chunk
        Map<Model, List<Entity>> modelEntityMap = new HashMap<>();
        
        for (var entry : scene.getModelMap().entrySet()) {
            if (!entry.getKey().equals("chunk")) {
                Model model = entry.getValue();
                List<Entity> entities = model.getEntitiesList();
                if (!entities.isEmpty()) {
                    modelEntityMap.put(model, entities);
                }
            }
        }
        
        // Renderizza ogni modello con tutte le sue entità
        for (var entry : modelEntityMap.entrySet()) {
            Model model = entry.getKey();
            List<Entity> entities = entry.getValue();
            
            for (Mesh mesh : model.getMeshList()) {
                glBindVertexArray(mesh.getVaoId());
                
                for (Entity entity : entities) {
                    entity.updateModelMatrix();
                    uniformsMap.setUniform("modelMatrix", entity.getModelMatrix());
                    glDrawElements(GL_TRIANGLES, mesh.getNumVertices(), GL_UNSIGNED_INT, 0);
                }
                
                glBindVertexArray(0);
            }
        }
    }

    private void createUniforms() {
        uniformsMap = new UniformsMap(shaderProgram.getProgramId());
        uniformsMap.createUniform("projectionMatrix");
        uniformsMap.createUniform("modelMatrix");
        uniformsMap.createUniform("txtSampler");
        uniformsMap.createUniform("viewMatrix");
    }
}package scene;

import org.joml.Vector4f;
import graphics.Mesh;
import graphics.Model;
import graphics.Projection;
import graphics.TextureCacheAtlas;
import world.Block;
import world.Block.BlockType;
import world.Chunk;
import world.ChunkPosition;
import world.World;
import java.util.*;

public class Scene {
    private static TextureCacheAtlas textureCacheAtlas;
    private static Map<String, Model> modelMap;
    private static Map<String, Entity> entityMap;

    private static Projection projection;
    private static Camera camera;
    private static World world;

    private int currentCenterChunkX = Integer.MIN_VALUE;
    private int currentCenterChunkZ = Integer.MIN_VALUE;

    static {
        modelMap = new HashMap<>();
        entityMap = new HashMap<>();
    }

    public Scene(int width, int height) {
        projection = new Projection(width, height);
        camera = new Camera();
        textureCacheAtlas = new TextureCacheAtlas("textures/atlas2.png", 512, 512, 16);
    }

    public static void addEntity(Entity entity) {
        String modelId = entity.getModelId();
        Model model = modelMap.get(modelId);
        if (model == null)
            throw new RuntimeException("Modello non trovato: " + modelId);
        model.getEntitiesList().add(entity);
        entityMap.put(entity.getId(), entity);
    }

    public static void addModel(Model model) {
        modelMap.put(model.getId(), model);
    }

    public void cleanup() {
        modelMap.clear();
        entityMap.clear();
    }

    public Map<String, Model> getModelMap() {
        return modelMap;
    }

    public Projection getProjection() {
        return projection;
    }

    public void resize(int width, int height) {
        projection.updateProjMatrix(width, height);
    }

    public Camera getCamera() {
        return camera;
    }

    public static Vector4f getBlockTextureRegion(BlockType type, Block.Face face) {
        String textureKey;
        
        switch (type) {
            case GRASS:
                if (face == Block.Face.TOP) {
                    textureKey = "grass_top";
                } else if (face == Block.Face.BOTTOM) {
                    textureKey = "dirt";
                } else {
                    textureKey = "grass_side";
                }
                break;
            case DIRT:
                textureKey = "dirt";
                break;
            case STONE:
                textureKey = "stone";
                break;
            case WOOD:
                textureKey = "wood";
                break;
            case LEAVES:
                textureKey = "leaves";
                break;
            default:
                textureKey = "default";
                break;
        }
        
        // Otteniamo le coordinate UV dall'atlas
        return textureCacheAtlas.getTextureRegion(textureKey);
    }

    public void cleanupChunk(Chunk chunk) {
        // Rimuovi l'entità del chunk se esiste
        Entity chunkEntity = chunk.getChunkEntity();
        if (chunkEntity != null) {
            removeEntity(chunkEntity.getId());
        }
    }

    public void updateWorldGeneration(float playerX, float playerZ) {
        int newCenterChunkX = (int) Math.floor(playerX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int newCenterChunkZ = (int) Math.floor(playerZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        if (newCenterChunkX == currentCenterChunkX && newCenterChunkZ == currentCenterChunkZ) {
            return;
        }
        currentCenterChunkX = newCenterChunkX;
        currentCenterChunkZ = newCenterChunkZ;

        Map<ChunkPosition, Chunk> loadedChunks = world.getLoadedChunks();
        int renderDistance = world.getRenderDistance();

        Set<ChunkPosition> chunksToRemove = new HashSet<>();
        for (Map.Entry<ChunkPosition, Chunk> entry : loadedChunks.entrySet()) {
            ChunkPosition chunkPos = entry.getKey();
            int chunkDistanceX = Math.abs(chunkPos.getX() - currentCenterChunkX);
            int chunkDistanceZ = Math.abs(chunkPos.getZ() - currentCenterChunkZ);
            if (chunkDistanceX > renderDistance || chunkDistanceZ > renderDistance) {
                chunksToRemove.add(chunkPos);
            }
        }
        
        for (ChunkPosition posToRemove : chunksToRemove) {
            Chunk chunkToRemove = loadedChunks.get(posToRemove);
            if (chunkToRemove != null) {
                cleanupChunk(chunkToRemove);
            }
            loadedChunks.remove(posToRemove);
        }

        for (int dx = -renderDistance; dx <= renderDistance; dx++) {
            for (int dz = -renderDistance; dz <= renderDistance; dz++) {
                int chunkX = currentCenterChunkX + dx;
                int chunkZ = currentCenterChunkZ + dz;
                ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);
                if (!loadedChunks.containsKey(chunkPos)) {
                    Chunk chunk = new Chunk(chunkX, chunkZ);
                    loadedChunks.put(chunkPos, chunk);
                    
                    // Genera immediatamente la mesh per il nuovo chunk
                    chunk.buildMesh(world, this);
                }
            }
        }
    }

    public World getWorld() {
        return world;
    }

    public void setWorld(World worldd) {
        world = worldd;
    }

    public TextureCacheAtlas getTextureCacheAtlas() {
        return textureCacheAtlas;
    }

    public void removeEntity(String entityId) {
        Entity entity = entityMap.remove(entityId);
        if (entity == null)
            return;
        Model model = modelMap.get(entity.getModelId());
        if (model != null) {
            var list = model.getEntitiesList();
            int index = list.indexOf(entity);
            if (index != -1) {
                int last = list.size() - 1;
                list.set(index, list.get(last));
                list.remove(last);
            }
        }
    }

    public void registerChunkModel(Mesh mesh) {
        if (mesh == null) {
            System.err.println("Tentativo di registrare una mesh null");
            return;
        }
        
        // Verificare se il modello chunk esiste già
        Model existingModel = modelMap.get("chunk");
        if (existingModel != null) {
            // Aggiungere la mesh al modello esistente
            existingModel.getMeshList().clear(); // Rimuovi le mesh esistenti
            existingModel.getMeshList().add(mesh);
        } else {
            // Creare un nuovo modello per i chunk
            List<Mesh> meshes = new ArrayList<>();
            meshes.add(mesh);
            Model model = new Model("chunk", meshes);
            modelMap.put("chunk", model);
        }
    }

    public void addChunkEntity(Entity entity) {
        // Aggiunge l'entità alla lista delle entità e al modello chunk
        entityMap.put(entity.getId(), entity);
        
        Model model = modelMap.get("chunk");
        if (model != null) {
            model.getEntitiesList().add(entity);
        }
    }

    public void updateChunkMesh(String chunkId, Mesh newMesh) {
        if (newMesh == null) {
            System.err.println("Tentativo di aggiornare con mesh null per chunk: " + chunkId);
            return;
        }
        
        // Aggiorna solo la mesh del chunk specificato
        Entity entity = entityMap.get(chunkId);
        if (entity != null) {
            Model chunkModel = modelMap.get(entity.getModelId());
            if (chunkModel != null) {
                // Trova l'indice dell'entità nel modello
                int index = chunkModel.getEntitiesList().indexOf(entity);
                if (index >= 0 && index < chunkModel.getMeshList().size()) {
                    // Sostituisci la mesh all'indice corrispondente
                    if (chunkModel.getMeshList().get(index) != null) {
                        chunkModel.getMeshList().get(index).cleanup();
                    }
                    chunkModel.getMeshList().set(index, newMesh);
                }
            }
        }
    }
}package scene;

import org.joml.Matrix4f;
import org.joml.Vector3f;

public class Frustum {
    private Plane[] planes;

    public Frustum() {
        planes = new Plane[6];
        for (int i = 0; i < 6; i++) {
            planes[i] = new Plane();
        }
    }

    public void update(Matrix4f viewMatrix, Matrix4f projMatrix) {
        Matrix4f clipMatrix = new Matrix4f();
        projMatrix.mul(viewMatrix, clipMatrix);

        planes[0].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 0),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 0),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 0),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 0));
        planes[0].normalize();

        planes[1].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 0),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 0),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 0),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 0));
        planes[1].normalize();

        planes[2].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 1),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 1),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 1),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 1));
        planes[2].normalize();

        planes[3].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 1),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 1),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 1),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 1));
        planes[3].normalize();

        planes[4].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 2),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 2),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 2),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 2));
        planes[4].normalize();

        planes[5].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 2),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 2),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 2),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 2));
        planes[5].normalize();
    }

    public boolean isBoxInFrustum(Vector3f min, Vector3f max) {
        for (Plane plane : planes) {
            if (plane.classifyBox(min, max) == Plane.OUTSIDE) {
                return false;
            }
        }
        return true;
    }
}package scene;

import org.joml.*;
import java.lang.Math;

public class Camera {
    private Vector3f position, direction, right, up;
    private Vector2f rotation;
    private Matrix4f viewMatrix;
    private Frustum frustum;

    public Camera() {
        position = new Vector3f();
        direction = new Vector3f();
        right = new Vector3f();
        up = new Vector3f();
        rotation = new Vector2f();
        viewMatrix = new Matrix4f();
    }

    public void addRotation(float x, float y) {
        rotation.y += x;
        rotation.x += y;
        float pitchLimit = (float) Math.toRadians(89.0);
        if (rotation.x > pitchLimit)
            rotation.x = pitchLimit;
        if (rotation.x < -pitchLimit)
            rotation.x = -pitchLimit;
        recalculate();
    }

    public void moveForward(float inc) {
        viewMatrix.positiveZ(direction).negate().mul(inc);
        position.add(direction);
        recalculate();
    }

    public void moveBackwards(float inc) {
        viewMatrix.positiveZ(direction).negate().mul(inc);
        position.sub(direction);
        recalculate();
    }

    public void moveLeft(float inc) {
        viewMatrix.positiveX(right).mul(inc);
        position.sub(right);
        recalculate();
    }

    public void moveRight(float inc) {
        viewMatrix.positiveX(right).mul(inc);
        position.add(right);
        recalculate();
    }

    public void moveUp(float inc) {
        viewMatrix.positiveY(up).mul(inc);
        position.add(up);
        recalculate();
    }

    public void moveDown(float inc) {
        viewMatrix.positiveY(up).mul(inc);
        position.sub(up);
        recalculate();
    }

    private void recalculate() {
        viewMatrix.identity()
                .rotateX(rotation.x)
                .rotateY(rotation.y)
                .translate(-position.x, -position.y, -position.z);
    }

    public void setPosition(float x, float y, float z) {
        position.set(x, y, z);
        recalculate();
    }

    public Matrix4f getViewMatrix() {
        return viewMatrix;
    }

    public Vector3f getPosition() {
        return position;
    }

    public Frustum getFrustum() {
        if (frustum == null)
            frustum = new Frustum();
        return frustum;
    }
}package scene;

import org.joml.*;

public class Entity {
    private final String id;
    private final String modelId;
    private Matrix4f modelMatrix;
    private Vector4f textureRegion;
    private Vector3f position;
    private Quaternionf rotation;
    private float scale;

    public Entity(String id, String modelId, Vector4f textureRegion) {
        this.id = id;
        this.modelId = modelId;
        this.textureRegion = textureRegion;
        modelMatrix = new Matrix4f();
        position = new Vector3f();
        rotation = new Quaternionf();
        scale = 1;
    }

    public String getId() {
        return id;
    }

    public String getModelId() {
        return modelId;
    }

    public Matrix4f getModelMatrix() {
        return modelMatrix;
    }

    public Vector3f getPosition() {
        return position;
    }

    public Quaternionf getRotation() {
        return rotation;
    }

    public float getScale() {
        return scale;
    }

    public void setPosition(float x, float y, float z) {
        position.set(x, y, z);
    }

    public void setRotation(float x, float y, float z, float angle) {
        rotation.fromAxisAngleRad(x, y, z, angle);
    }

    public void setScale(float scale) {
        this.scale = scale;
    }

    public void updateModelMatrix() {
        modelMatrix.translationRotateScale(position, rotation, scale);
    }

    public Vector4f getTextureRegion() {
        return textureRegion;
    }

    public void setTextureRegion(Vector4f textureRegion) {
        this.textureRegion = textureRegion;
    }
}package scene;

import org.joml.Vector3f;

public class Plane {
    public static final int OUTSIDE = -1;
    private float a, b, c, d;

    public void set(float a, float b, float c, float d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    public void normalize() {
        float mag = (float) Math.sqrt(a * a + b * b + c * c);
        a /= mag;
        b /= mag;
        c /= mag;
        d /= mag;
    }

    public int classifyBox(Vector3f min, Vector3f max) {
        float px = (a >= 0) ? max.x : min.x;
        float py = (b >= 0) ? max.y : min.y;
        float pz = (c >= 0) ? max.z : min.z;
        if (a * px + b * py + c * pz + d < 0)
            return OUTSIDE;
        return 1;
    }
}package graphics;

import java.util.HashMap;
import java.util.Map;
import org.joml.Vector4f;
import world.Block.BlockType;

public class TextureCacheAtlas {
    private TextureAtlas atlas;
    private Map<String, float[]> uvCache;
    private Map<String, int[]> texturePositions;
    private Map<BlockType, Vector4f> textureRegionCache;
    private Map<String, Vector4f> textureRegionStringCache;

    public TextureCacheAtlas(String texturePath, int atlasWidth, int atlasHeight, int tileSize) {
        atlas = new TextureAtlas(texturePath, atlasWidth, atlasHeight, tileSize);
        uvCache = new HashMap<>();
        texturePositions = initializeTexturePositions();
        textureRegionCache = new HashMap<>();
        textureRegionStringCache = new HashMap<>();
    }

    private Map<String, int[]> initializeTexturePositions() {
        Map<String, int[]> positions = new HashMap<>();
        // Rimuovo le definizioni duplicate e correggo le posizioni
        positions.put("grass_top", new int[] { 7, 14 });
        positions.put("grass_side", new int[] { 6, 14 });
        positions.put("dirt", new int[] { 8, 5 });
        positions.put("stone", new int[] { 19, 6 });
        positions.put("wood", new int[] { 1, 13 });
        positions.put("leaves", new int[] { 9, 12 });
        positions.put("bedrock", new int[] { 1, 1 });
        positions.put("default", new int[] { 0, 1 });
        return positions;
    }

    public TextureAtlas getAtlasTexture() {
        return atlas;
    }

    public void cleanup() {
        atlas.cleanup();
        uvCache.clear();
        texturePositions.clear();
        textureRegionCache.clear();
        textureRegionStringCache.clear();
    }

    public Vector4f getTextureRegion(BlockType type) {
        return textureRegionCache.computeIfAbsent(type, t -> {
            String textureName = switch (t) {
                case GRASS -> "grass_top";
                case DIRT -> "dirt";
                case STONE -> "stone";
                case WOOD -> "wood";
                case LEAVES -> "leaves";
                default -> "default";
            };
            if (!texturePositions.containsKey(textureName)) {
                System.err.println("Warning: Texture '" + textureName + "' not found. Using default.");
                textureName = "default";
            }
            int[] pos = texturePositions.get(textureName);
            float[] baseUV = atlas.getUVCoordinates(pos[0], pos[1]);
            
            return new Vector4f(baseUV[0], baseUV[1], baseUV[2], baseUV[3]);
        });
    }

    public Vector4f getTextureRegion(String textureName) {
        return textureRegionStringCache.computeIfAbsent(textureName, t -> {
            String actualTextureName = textureName; 
            
            if (!texturePositions.containsKey(actualTextureName)) {
                System.err.println("Warning: Texture '" + actualTextureName + "' not found. Using default.");
                actualTextureName = "default";
            }
            
            int[] pos = texturePositions.get(actualTextureName);
            float[] baseUV = atlas.getUVCoordinates(pos[0], pos[1]);
            
            System.out.println("Texture coordinates for " + actualTextureName + ": " + 
                baseUV[0] + ", " + baseUV[1] + ", " + baseUV[2] + "," + baseUV[3]);
            
            return new Vector4f(baseUV[0], baseUV[1], baseUV[2], baseUV[3]);
        });
    }

    public float[] getUVCoordinates(String textureName) {
        if (!uvCache.containsKey(textureName)) {
            if (!texturePositions.containsKey(textureName)) {
                System.err.println("Warning: Texture '" + textureName + "' not found. Using default.");
                textureName = "default";
            }
            int[] pos = texturePositions.get(textureName);
            float[] baseUV = atlas.getUVCoordinates(pos[0], pos[1]);
            float[] formattedUV = new float[8];
            formattedUV[0] = baseUV[0];
            formattedUV[1] = baseUV[1];
            formattedUV[2] = baseUV[0];
            formattedUV[3] = baseUV[3];
            formattedUV[4] = baseUV[2];
            formattedUV[5] = baseUV[3];
            formattedUV[6] = baseUV[2];
            formattedUV[7] = baseUV[1];
            uvCache.put(textureName, formattedUV);
        }
        return uvCache.get(textureName);
    }
}package graphics;

import java.util.*;
import static org.lwjgl.opengl.GL20.*;
import utils.Utils;

public class ShaderProgram {
    private final int programId;

    public ShaderProgram(List<ShaderModuleData> modules) {
        programId = glCreateProgram();
        if (programId == 0)
            throw new RuntimeException("Could not create Shader Program");
        List<Integer> shaderModules = new ArrayList<>();
        for (ShaderModuleData s : modules) {
            shaderModules.add(createShader(Utils.readFile(s.shaderFile), s.shaderType));
        }
        link(shaderModules);
    }

    public void bind() {
        glUseProgram(programId);
    }

    public void unbind() {
        glUseProgram(0);
    }

    public void cleanup() {
        unbind();
        if (programId != 0)
            glDeleteProgram(programId);
    }

    public int getProgramId() {
        return programId;
    }

    protected int createShader(String code, int type) {
        int shaderId = glCreateShader(type);
        if (shaderId == 0)
            throw new RuntimeException("Error creating shader type: " + type);
        glShaderSource(shaderId, code);
        glCompileShader(shaderId);
        if (glGetShaderi(shaderId, GL_COMPILE_STATUS) == 0)
            throw new RuntimeException("Error compiling shader: " + glGetShaderInfoLog(shaderId, 1024));
        glAttachShader(programId, shaderId);
        return shaderId;
    }

    private void link(List<Integer> shaderModules) {
        glLinkProgram(programId);
        if (glGetProgrami(programId, GL_LINK_STATUS) == 0)
            throw new RuntimeException("Error linking Shader Program: " + glGetProgramInfoLog(programId, 1024));
        for (int shaderId : shaderModules) {
            glDetachShader(programId, shaderId);
            glDeleteShader(shaderId);
        }
    }

    public record ShaderModuleData(String shaderFile, int shaderType) {
    }
}package graphics;

import org.joml.Matrix4f;
import org.joml.Vector4f;
import org.lwjgl.system.MemoryStack;
import java.util.HashMap;
import java.util.Map;
import static org.lwjgl.opengl.GL20.*;

public class UniformsMap {
    private int programId;
    private Map<String, Integer> uniforms;

    public UniformsMap(int programId) {
        this.programId = programId;
        uniforms = new HashMap<>();
    }

    public void createUniform(String uniformName) {
        int location = glGetUniformLocation(programId, uniformName);
        if (location < 0)
            throw new RuntimeException("Could not find uniform: " + uniformName);
        uniforms.put(uniformName, location);
    }

    private int getUniformLocation(String name) {
        Integer loc = uniforms.get(name);
        if (loc == null)
            throw new RuntimeException("Uniform not found: " + name);
        return loc;
    }

    public void setUniform(String name, int value) {
        glUniform1i(getUniformLocation(name), value);
    }

    public void setUniform(String name, Matrix4f value) {
        try (MemoryStack stack = MemoryStack.stackPush()) {
            glUniformMatrix4fv(getUniformLocation(name), false, value.get(stack.mallocFloat(16)));
        }
    }

    public void setUniform(String name, Vector4f value) {
        glUniform4f(getUniformLocation(name), value.x, value.y, value.z, value.w);
    }
}package graphics;

import org.joml.Matrix4f;

public class Projection {
    private static final float FOV = (float) Math.toRadians(60.0);
    private static final float Z_NEAR = 0.01f;
    private static final float Z_FAR = 1000f;
    private Matrix4f projMatrix;

    public Projection(int width, int height) {
        projMatrix = new Matrix4f();
        updateProjMatrix(width, height);
    }

    public Matrix4f getProjMatrix() {
        return projMatrix;
    }

    public void updateProjMatrix(int width, int height) {
        projMatrix.setPerspective(FOV, (float) width / height, Z_NEAR, Z_FAR);
    }
}package graphics;

import org.lwjgl.opengl.GL30;
import org.lwjgl.system.MemoryUtil;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.List;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL20.*;
import static org.lwjgl.opengl.GL30.*;

public class Mesh {
    private int numVertices;
    private int vaoId;
    private List<Integer> vboIdList;

    public Mesh(float[] positions, float[] textCoords, int[] indices) {
        numVertices = indices.length;
        vboIdList = new ArrayList<>();
        vaoId = glGenVertexArrays();
        glBindVertexArray(vaoId);

        int vboId = glGenBuffers();
        vboIdList.add(vboId);
        FloatBuffer posBuffer = MemoryUtil.memAllocFloat(positions.length);
        posBuffer.put(positions).flip();
        glBindBuffer(GL_ARRAY_BUFFER, vboId);
        glBufferData(GL_ARRAY_BUFFER, posBuffer, GL_STATIC_DRAW);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);

        vboId = glGenBuffers();
        vboIdList.add(vboId);
        FloatBuffer texBuffer = MemoryUtil.memAllocFloat(textCoords.length);
        texBuffer.put(textCoords).flip();
        glBindBuffer(GL_ARRAY_BUFFER, vboId);
        glBufferData(GL_ARRAY_BUFFER, texBuffer, GL_STATIC_DRAW);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 2, GL_FLOAT, false, 0, 0);

        vboId = glGenBuffers();
        vboIdList.add(vboId);
        IntBuffer indicesBuffer = MemoryUtil.memAllocInt(indices.length);
        indicesBuffer.put(indices).flip();
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboId);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesBuffer, GL_STATIC_DRAW);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
        MemoryUtil.memFree(posBuffer);
        MemoryUtil.memFree(texBuffer);
        MemoryUtil.memFree(indicesBuffer);
    }

    public void cleanup() {
        vboIdList.forEach(GL30::glDeleteBuffers);
        glDeleteVertexArrays(vaoId);
    }

    public int getNumVertices() {
        return numVertices;
    }

    public int getVaoId() {
        return vaoId;
    }
}package graphics;

import static org.lwjgl.opengl.GL11.*;
import core.Window;
import scene.Scene;
import scene.SceneRender;

public class Render {
    private SceneRender sceneRender;

    public Render() {
        org.lwjgl.opengl.GL.createCapabilities();
        glEnable(GL_DEPTH_TEST);
        sceneRender = new SceneRender();
    }

    public void cleanup() {
        sceneRender.cleanup();
    }

    public void render(Window window, Scene scene) {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glViewport(0, 0, window.getWidth(), window.getHeight());
        sceneRender.render(window, scene);
    }
}package graphics;

import org.lwjgl.BufferUtils;
import org.lwjgl.system.MemoryStack;
import core.Main;
import java.io.IOException;
import java.io.InputStream;
import java.nio.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.stb.STBImage.*;

public class TextureAtlas {
    private int textureId;
    private int atlasWidth;
    private int atlasHeight;
    private int tileSize;
    private String texturePath;

    public TextureAtlas(String texturePath, int atlasWidth, int atlasHeight, int tileSize) {
        this.texturePath = texturePath;
        this.atlasWidth = atlasWidth;
        this.atlasHeight = atlasHeight;
        this.tileSize = tileSize;

        try (MemoryStack stack = MemoryStack.stackPush()) {
            InputStream in = Main.class.getClassLoader().getResourceAsStream(texturePath);
            if (in == null) {
                throw new RuntimeException("Texture not found: " + texturePath);
            }
            byte[] bytes = in.readAllBytes();
            ByteBuffer imageBuffer = BufferUtils.createByteBuffer(bytes.length);
            imageBuffer.put(bytes).flip();
            IntBuffer w = stack.mallocInt(1), h = stack.mallocInt(1), channels = stack.mallocInt(1);
            ByteBuffer buf = stbi_load_from_memory(imageBuffer, w, h, channels, 4);
            if (buf == null) {
                throw new RuntimeException("Failed to load texture: " + stbi_failure_reason());
            }
            generateTexture(w.get(), h.get(), buf);
            stbi_image_free(buf);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void generateTexture(int width, int height, ByteBuffer buf) {
        textureId = glGenTextures();
        glBindTexture(GL_TEXTURE_2D, textureId);
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    public void bind() {
        glBindTexture(GL_TEXTURE_2D, textureId);
    }

    public float[] getUVCoordinates(int x, int y) {
        float margin = 0.000f;
        
        float uMin = (x * tileSize + margin) / (float) atlasWidth;
        float vMin = (y * tileSize + margin) / (float) atlasHeight;
        float uMax = ((x + 1) * tileSize - margin) / (float) atlasWidth;
        float vMax = ((y + 1) * tileSize - margin) / (float) atlasHeight;

        // Debug output per verificare i valori
        System.out.println("Texture UV coordinates: [" + uMin + ", " + vMin + ", " + uMax + ", " + vMax + "]");
        
        return new float[] { uMin, vMin, uMax, vMax };
    }

    public String getTexturePath() {
        return texturePath;
    }

    public void cleanup() {
        glDeleteTextures(textureId);
    }
}
package graphics;

import java.util.ArrayList;
import java.util.List;
import scene.Entity;

public class Model {
    private final String id;
    private List<Entity> entitiesList;
    private List<Mesh> meshList;

    public Model(String id, List<Mesh> meshList) {
        this.id = id;
        this.meshList = meshList;
        this.entitiesList = new ArrayList<>();
    }

    public List<Entity> getEntitiesList() {
        return entitiesList;
    }

    public String getId() {
        return id;
    }

    public List<Mesh> getMeshList() {
        return meshList;
    }
}package entities;

public class Mob {
    
}
package entities;

public class Player {
    
}
package entities;

public class Entity {
    
}
