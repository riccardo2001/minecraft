package ui;

public class Menu {
    
}
package ui;

public class HUD {
    
}
package core;

import graphics.Render;
import scene.Scene;

public interface IAppLogic {

    void cleanup();

    void init(Window window, Scene scene, Render render);

    void input(Window window, Scene scene, float diffTimeMillis);

    void update(Window window, Scene scene, long diffTimeMillis);
}
package core;

import org.joml.Vector2f;
import static org.lwjgl.glfw.GLFW.*;

public class MouseInput {
    private Vector2f currentPos, displVec, previousPos;
    private boolean leftButtonPressed, rightButtonPressed;

    public MouseInput(long windowHandle) {
        glfwSetInputMode(windowHandle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
        previousPos = new Vector2f(-1, -1);
        currentPos = new Vector2f();
        displVec = new Vector2f();
        glfwSetCursorPosCallback(windowHandle, (handle, xpos, ypos) -> {
            currentPos.x = (float) xpos;
            currentPos.y = (float) ypos;
        });
        glfwSetMouseButtonCallback(windowHandle, (handle, button, action, mode) -> {
            leftButtonPressed = button == GLFW_MOUSE_BUTTON_1 && action == GLFW_PRESS;
            rightButtonPressed = button == GLFW_MOUSE_BUTTON_2 && action == GLFW_PRESS;
        });
    }

    public Vector2f getCurrentPos() {
        return currentPos;
    }

    public Vector2f getDisplVec() {
        return displVec;
    }

    public void input() {
        displVec.set(0, 0);
        if (previousPos.x < 0 || previousPos.y < 0) {
            previousPos.set(currentPos);
            return;
        }
        displVec.x = currentPos.x - previousPos.x;
        displVec.y = currentPos.y - previousPos.y;
        previousPos.set(currentPos);
    }

    public boolean isLeftButtonPressed() {
        return leftButtonPressed;
    }

    public boolean isRightButtonPressed() {
        return rightButtonPressed;
    }
}package core;

import org.lwjgl.glfw.GLFWVidMode;
import org.lwjgl.glfw.GLFWErrorCallback;
import java.util.concurrent.Callable;

import static org.lwjgl.glfw.Callbacks.glfwFreeCallbacks;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.system.MemoryUtil.NULL;

public class Window {
    private final long windowHandle;
    private int width, height;
    private String title;
    private Callable<Void> resizeFunc;
    private MouseInput mouseInput;

    public static class WindowOptions {
        public boolean compatibleProfile;
        public int fps;
        public int height;
        public int ups;
        public int width;
    }

    public Window(String title, WindowOptions opts, Callable<Void> resizeFunc) {
        this.resizeFunc = resizeFunc;
        if (!glfwInit()) {
            throw new IllegalStateException("Unable to initialize GLFW");
        }
        glfwDefaultWindowHints();
        glfwWindowHint(GLFW_VISIBLE, GL_FALSE);
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
        if (opts.compatibleProfile) {
            glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);
        } else {
            glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
            glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
        }
        if (opts.width > 0 && opts.height > 0) {
            width = opts.width;
            height = opts.height;
        } else {
            glfwWindowHint(GLFW_MAXIMIZED, GLFW_TRUE);
            GLFWVidMode vidMode = glfwGetVideoMode(glfwGetPrimaryMonitor());
            width = vidMode.width();
            height = vidMode.height();
        }
        windowHandle = glfwCreateWindow(width, height, title, NULL, NULL);
        if (windowHandle == NULL) {
            throw new RuntimeException("Failed to create GLFW window");
        }
        glfwSetFramebufferSizeCallback(windowHandle, (window, w, h) -> resized(w, h));
        glfwSetKeyCallback(windowHandle, (window, key, scancode, action, mods) -> {
            if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {
                glfwSetWindowShouldClose(windowHandle, true);
            }
        });
        glfwMakeContextCurrent(windowHandle);
        if (opts.fps > 0) {
            glfwSwapInterval(0);
        } else {
            glfwSwapInterval(1);
        }
        glfwShowWindow(windowHandle);
        int[] wArr = new int[1], hArr = new int[1];
        glfwGetFramebufferSize(windowHandle, wArr, hArr);
        width = wArr[0];
        height = hArr[0];
        mouseInput = new MouseInput(windowHandle);
    }

    protected void resized(int w, int h) {
        width = w;
        height = h;
        try {
            resizeFunc.call();
        } catch (Exception e) {
        }
    }

    public void pollEvents() {
        glfwPollEvents();
    }

    public void update() {
        glfwSwapBuffers(windowHandle);
    }

    public boolean windowShouldClose() {
        return glfwWindowShouldClose(windowHandle);
    }

    public MouseInput getMouseInput() {
        return mouseInput;
    }

    public boolean isKeyPressed(int keyCode) {
        return glfwGetKey(windowHandle, keyCode) == GLFW_PRESS;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    public long getWindowHandle() {
        return windowHandle;
    }

    public void setTitle(String title) {
        this.title = title;
        glfwSetWindowTitle(windowHandle, title);
    }

    public void cleanup() {
        glfwFreeCallbacks(windowHandle);
        glfwDestroyWindow(windowHandle);
        glfwTerminate();
        GLFWErrorCallback callback = glfwSetErrorCallback(null);
        if (callback != null) {
            callback.free();
        }
    }

    public String getTitle() {
        return title;
    }
}package core;

public class Timer {
    
}
package core;

import graphics.Render;
import scene.Scene;

public class Engine {
    public static final int TARGET_UPS = 60;
    private final IAppLogic appLogic;
    private final Window window;
    private final Render render;
    private final Scene scene;
    private boolean running;
    private int targetFps;
    private int targetUps;

    public Engine(String windowTitle, Window.WindowOptions opts, IAppLogic appLogic) {
        window = new Window(windowTitle, opts, () -> {
            resize();
            return null;
        });
        targetFps = opts.fps;
        targetUps = opts.ups;
        render = new Render();
        scene = new Scene(window.getWidth(), window.getHeight());
        this.appLogic = appLogic;
        this.appLogic.init(window, scene, render);
        running = true;
    }

    private void cleanup() {
        appLogic.cleanup();
        window.cleanup();
        render.cleanup();
        scene.cleanup();
    }

    private void resize() {
        scene.resize(window.getWidth(), window.getHeight());
    }

    private void run() {
        // Tempo fisso per update e render
        final double nsPerUpdate = 1e9 / targetUps; // ad es. 33,33 ms per update
        final double nsPerFrame = targetFps > 0 ? 1e9 / targetFps : 0; // ad es. 16,66 ms per frame per 60fps

        long lastTime = System.nanoTime();
        long lastUpdateTime = lastTime;
        long lastFrameTime = lastTime;
        int frames = 0;
        long fpsTimer = lastTime;

        while (running && !window.windowShouldClose()) {
            window.pollEvents();
            long now = System.nanoTime();

            // Update: esegue gli update (world generation, logica) solo quando è passato il
            // tempo necessario
            if (now - lastUpdateTime >= nsPerUpdate) {
                long updateDiffMillis = (now - lastUpdateTime) / 1_000_000L;
                appLogic.update(window, scene, updateDiffMillis);
                lastUpdateTime = now;
            }

            // Input e Render: esegue input e rendering se è passato il tempo per un frame
            if (targetFps <= 0 || now - lastFrameTime >= nsPerFrame) {
                long frameDiffMillis = (now - lastFrameTime) / 1_000_000L;
                appLogic.input(window, scene, (float) frameDiffMillis);
                render.render(window, scene);
                window.update();
                frames++;
                lastFrameTime = now;
            }

            // Aggiorna il contatore FPS ogni secondo
            if (now - fpsTimer >= 1e9) {
                window.setTitle("Minecraft | FPS: " + frames);
                frames = 0;
                fpsTimer = now;
            }

            lastTime = now;
        }
        cleanup();
    }

    public void start() {
        running = true;
        run();
    }

    public void stop() {
        running = false;
    }
}package core;

import graphics.Render;
import scene.Camera;
import scene.Scene;
import world.World;
import org.joml.Vector2f;
import static org.lwjgl.glfw.GLFW.*;

public class Main implements IAppLogic {
    private static final float MOUSE_SENSITIVITY = 0.1f;
    private static final float MOVEMENT_SPEED = 0.005f;

    public static void main(String[] args) {
        Main main = new Main();
        Window.WindowOptions opts = new Window.WindowOptions();
        opts.width = 1280;
        opts.height = 720;
        opts.fps = 60;
        opts.ups = Engine.TARGET_UPS;
        opts.compatibleProfile = false;
        Engine gameEng = new Engine("Minecraft", opts, main);
        gameEng.start();
    }

    @Override
    public void cleanup() {
        // Cleanup eventuale
    }

    @Override
    public void init(Window window, Scene scene, Render render) {
        scene.setWorld(new World());
        scene.getWorld().generateInitialWorld(0, 0);
        scene.getCamera().setPosition(0f, 75f, 0f);
        System.out.println("World generated");
    }

    @Override
    public void input(Window window, Scene scene, float diffTimeMillis) {
        // Aggiorna il movimento del mouse
        window.getMouseInput().input();

        float move = diffTimeMillis * MOVEMENT_SPEED;
        Camera camera = scene.getCamera();
        MouseInput mouseInput = window.getMouseInput();
        Vector2f displVec = mouseInput.getDisplVec();

        if (window.isKeyPressed(GLFW_KEY_W)) {
            camera.moveForward(move);
        } else if (window.isKeyPressed(GLFW_KEY_S)) {
            camera.moveBackwards(move);
        }
        if (window.isKeyPressed(GLFW_KEY_A)) {
            camera.moveLeft(move);
        } else if (window.isKeyPressed(GLFW_KEY_D)) {
            camera.moveRight(move);
        }
        if (window.isKeyPressed(GLFW_KEY_SPACE)) {
            camera.moveUp(move);
        } else if (window.isKeyPressed(GLFW_KEY_LEFT_CONTROL)) {
            camera.moveDown(move);
        }

        camera.addRotation(
                (float) Math.toRadians(displVec.x * MOUSE_SENSITIVITY),
                (float) Math.toRadians(displVec.y * MOUSE_SENSITIVITY));
    }

    @Override
    public void update(Window window, Scene scene, long diffTimeMillis) {
        float playerX = scene.getCamera().getPosition().x;
        float playerZ = scene.getCamera().getPosition().z;
        scene.updateWorldGeneration(playerX, playerZ);
    }
}package core;

public class Settings {
    
}
package world;

import java.util.Objects;

public class ChunkPosition {
    int x, z;

    public ChunkPosition(int x, int z) {
        this.x = x;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        ChunkPosition that = (ChunkPosition) o;
        return x == that.x && z == that.z;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, z);
    }


    public int getX() {
        return this.x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getZ() {
        return this.z;
    }

    public void setZ(int z) {
        this.z = z;
    }

}
package world;

import java.util.HashMap;
import java.util.Map;

public class World {
    private Map<ChunkPosition, Chunk> loadedChunks;
    private int renderDistance = 1;

    public World() {
        this.loadedChunks = new HashMap<>();
    }

    public void generateInitialWorld(float centerX, float centerZ) {
        int centerChunkX = (int) Math.floor(centerX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int centerChunkZ = (int) Math.floor(centerZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        for (int dx = -renderDistance; dx <= renderDistance; dx++) {
            for (int dz = -renderDistance; dz <= renderDistance; dz++) {
                int chunkX = centerChunkX + dx;
                int chunkZ = centerChunkZ + dz;

                ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);

                if (!loadedChunks.containsKey(chunkPos)) {
                    // Passa il textureCache al costruttore di Chunk
                    Chunk chunk = new Chunk(chunkX, chunkZ);
                    loadedChunks.put(chunkPos, chunk);
                }
            }
        }
    }

    public void setBlockAtWorldPosition(float worldX, float worldY, float worldZ, Block.BlockType blockType) {
        int chunkX = (int) Math.floor(worldX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int chunkZ = (int) Math.floor(worldZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        int localX = (int) Math.floor((worldX % (Chunk.WIDTH * Block.BLOCK_SIZE)) / Block.BLOCK_SIZE);
        int localY = (int) Math.floor(worldY / Block.BLOCK_SIZE);
        int localZ = (int) Math.floor((worldZ % (Chunk.DEPTH * Block.BLOCK_SIZE)) / Block.BLOCK_SIZE);

        ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);
        Chunk chunk = loadedChunks.get(chunkPos);

        if (chunk != null) {
            Block newBlock = new Block(blockType);
            newBlock.setWorldPosition(worldX, worldY, worldZ);
            chunk.setBlock(localX, localY, localZ, newBlock);
        }
    }

    public Map<ChunkPosition, Chunk> getLoadedChunks() {
        return loadedChunks;
    }

    public Block getBlock(int x, int y, int z) {
        // Trova il chunk che contiene queste coordinate
        int chunkX = x >> 4; // Dividi per 16
        int chunkZ = z >> 4;

        Chunk chunk = getChunk(chunkX, chunkZ);
        if (chunk == null) {
            return null;
        }

        // Trova il blocco all'interno del chunk
        return chunk.getBlock(x & 15, y, z & 15);
    }

    public Chunk getChunk(int chunkX, int chunkZ) {
        ChunkPosition position = new ChunkPosition(chunkX, chunkZ);
        return loadedChunks.get(position);
    }

    public int getRenderDistance() {
        return renderDistance;
    }
}package world;

public class Chunk {
    public static final int WIDTH = 16;
    public static final int HEIGHT = 256;
    public static final int DEPTH = 16;

    private final int chunkX;
    private final int chunkZ;
    private Block[][][] blocks;
    private boolean isDirty;

    public Chunk(int chunkX, int chunkZ) {
        this.chunkX = chunkX;
        this.chunkZ = chunkZ;
        this.blocks = new Block[WIDTH][HEIGHT][DEPTH];
        this.isDirty = true;
        System.out.println("Generating Chunk at: " + chunkX + ", " + chunkZ);

        generateInitialTerrain();
    }

    private void generateInitialTerrain() {
        // Ciclo corretto: x da 0 a WIDTH, z da 0 a DEPTH, y da 0 a HEIGHT.
        for (int x = 0; x < WIDTH; x++) {
            for (int z = 0; z < DEPTH; z++) { // Usa DEPTH qui!
                int terrainHeight = calculateTerrainHeight(x, z);

                for (int y = 0; y < HEIGHT; y++) { // Usa HEIGHT per la verticale
                    Block.BlockType blockType = determineBlockType(x, y, z, terrainHeight);

                    if (blockType != Block.BlockType.AIR) {
                        float worldX = (chunkX * WIDTH + x) * Block.BLOCK_SIZE;
                        float worldY = y * Block.BLOCK_SIZE;
                        float worldZ = (chunkZ * DEPTH + z) * Block.BLOCK_SIZE;

                        Block block = new Block(blockType);
                        block.setWorldPosition(worldX, worldY, worldZ);

                        setBlock(x, y, z, block);
                    }
                }
            }
        }
    }

    private int calculateTerrainHeight(int localX, int localZ) {
        double noise1 = Math.sin(localX * 0.1) * 10;
        double noise2 = Math.cos(localZ * 0.2) * 8;
        double noise3 = Math.sin(localX * 0.05 + localZ * 0.05) * 15;

        return 64 + (int) (noise1 + noise2 + noise3);
    }

    private Block.BlockType determineBlockType(int x, int y, int z, int terrainHeight) {
        if (y == 0)
            return Block.BlockType.STONE;
        if (y < terrainHeight - 3)
            return Block.BlockType.STONE;
        if (y < terrainHeight - 1)
            return Block.BlockType.STONE;
        if (y < terrainHeight)
            return Block.BlockType.GRASS;
        return Block.BlockType.AIR;
    }

    public void setBlock(int x, int y, int z, Block block) {
        if (isValidPosition(x, y, z)) {
            blocks[x][y][z] = block;
            isDirty = true;
        }
    }

    public Block getBlock(int x, int y, int z) {
        return isValidPosition(x, y, z) ? blocks[x][y][z] : null;
    }

    private boolean isValidPosition(int x, int y, int z) {
        return x >= 0 && x < WIDTH &&
                y >= 0 && y < HEIGHT &&
                z >= 0 && z < DEPTH;
    }

    public boolean isDirty() {
        return isDirty;
    }

    public void resetDirtyFlag() {
        isDirty = false;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkZ() {
        return chunkZ;
    }

    public Block[][][] getBlocks() {
        return blocks;
    }
}package world;

import org.joml.Vector3f;

import scene.Camera;
import scene.Entity;
import scene.Scene;

public class Block {
    public static final float BLOCK_SIZE = 1.0f;
    private Entity blockEntity;
    private BlockType type;

    public enum BlockType {
        AIR,
        GRASS,
        DIRT,
        STONE,
        WOOD
    }

    public enum Face {
        TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT
    }

    public Block(BlockType type) {
        this.type = type;
        this.blockEntity = Scene.createEntity(type);
    }

    public void setWorldPosition(float x, float y, float z) {
        blockEntity.setPosition(x, y, z);
    }

    public Entity getEntity() {
        return blockEntity;
    }

    public BlockType getType() {
        return type;
    }

    public boolean isSolid() {
        return type != BlockType.AIR;
    }

    public void updateModelMatrix() {
        blockEntity.updateModelMatrix();
    }

    public static boolean isBlockVisible(Scene scene, Entity entity) {
        Camera camera = scene.getCamera();

        // 1. Frustum Culling - verifica se il blocco è nel campo visivo della camera
        if (!isInFrustum(camera, entity)) {
            return false;
        }

        // 2. Distance Culling - ignora blocchi troppo lontani
        float maxDistance = 100.0f; // Distanza massima di rendering
        Vector3f cameraPos = camera.getPosition();
        Vector3f blockPos = entity.getPosition();

        float distSquared = cameraPos.distanceSquared(blockPos);
        if (distSquared > maxDistance * maxDistance) {
            return false;
        }

        // 3. Occlusion Culling - verifica se il blocco è coperto
        // Questo è più complesso - implementazione semplificata
        if (isOccluded(scene, entity)) {
            return false;
        }

        return true;
    }

    /**
     * Verifica se un blocco è all'interno del frustum della camera
     */
    private static boolean isInFrustum(Camera camera, Entity entity) {
        // Ottieni le dimensioni dell'AABB del blocco (Axis-Aligned Bounding Box)
        Vector3f position = entity.getPosition();
        Vector3f min = new Vector3f(position.x - BLOCK_SIZE / 2,
                position.y - BLOCK_SIZE / 2,
                position.z - BLOCK_SIZE / 2);
        Vector3f max = new Vector3f(position.x + BLOCK_SIZE / 2,
                position.y + BLOCK_SIZE / 2,
                position.z + BLOCK_SIZE / 2);

        // Controlla se l'AABB è all'interno del frustum
        return camera.getFrustum().isBoxInFrustum(min, max);
    }

    /**
     * Verifica se un blocco è completamente coperto da altri blocchi
     * Questa è un'implementazione semplificata
     */
    private static boolean isOccluded(Scene scene, Entity entity) {
        // Implementazione semplice: un blocco è occluso se tutti i 6 lati sono coperti
        // da altri blocchi opachi (non trasparenti come vetro, acqua, ecc.)

        World world = scene.getWorld();
        Vector3f pos = entity.getPosition();
        int x = Math.round(pos.x);
        int y = Math.round(pos.y);
        int z = Math.round(pos.z);

        // Verifica tutti i 6 lati adiacenti
        boolean allSidesCovered = true;

        // Direzioni: su, giù, nord, sud, est, ovest
        int[][] directions = {
                { 0, 1, 0 }, { 0, -1, 0 }, { 0, 0, 1 }, { 0, 0, -1 }, { 1, 0, 0 }, { -1, 0, 0 }
        };

        for (int[] dir : directions) {
            Block adjacent = world.getBlock(x + dir[0], y + dir[1], z + dir[2]);
            if (adjacent == null || !adjacent.isOpaque()) {
                allSidesCovered = false;
                break;
            }
        }

        return allSidesCovered;
    }

    private boolean isOpaque() {
        return type != BlockType.AIR;
    }
}
package utils;

import java.io.*;
import core.Main;

public class Utils {
    public static String readFile(String filePath) {
        try {
            InputStream in = Main.class.getClassLoader().getResourceAsStream(filePath);
            if (in == null) {
                in = new FileInputStream(filePath);
            }
            String content = new String(in.readAllBytes());
            in.close();
            return content;
        } catch (IOException e) {
            throw new RuntimeException("Error reading file: " + filePath, e);
        }
    }
}package audio;

public class SoundManager {
    
}
package physics;

public class Gravity {
    
}
package physics;

public class Collision {
    
}
package scene;

import java.util.*;
import core.Window;
import graphics.Mesh;
import graphics.Model;
import graphics.ShaderProgram;
import graphics.TextureAtlas;
import graphics.TextureCacheAtlas;
import graphics.UniformsMap;
import world.Block;
import world.Chunk;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL13.*;
import static org.lwjgl.opengl.GL20.*;
import static org.lwjgl.opengl.GL30.*;

public class SceneRender {
    private ShaderProgram shaderProgram;
    private UniformsMap uniformsMap;

    public SceneRender() {
        List<ShaderProgram.ShaderModuleData> modules = new ArrayList<>();
        modules.add(new ShaderProgram.ShaderModuleData("shaders/scene.vert", GL_VERTEX_SHADER));
        modules.add(new ShaderProgram.ShaderModuleData("shaders/scene.frag", GL_FRAGMENT_SHADER));
        shaderProgram = new ShaderProgram(modules);
        createUniforms();
    }

    public void cleanup() {
        shaderProgram.cleanup();
    }

    public void render(Window window, Scene scene) {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glViewport(0, 0, window.getWidth(), window.getHeight());

        // Aggiorna il frustum una sola volta per frame
        scene.getCamera().getFrustum().update(scene.getCamera().getViewMatrix(), scene.getProjection().getProjMatrix());

        shaderProgram.bind();
        uniformsMap.setUniform("projectionMatrix", scene.getProjection().getProjMatrix());
        uniformsMap.setUniform("viewMatrix", scene.getCamera().getViewMatrix());
        uniformsMap.setUniform("txtSampler", 0);

        TextureCacheAtlas textureCache = scene.getTextureCacheAtlas();
        TextureAtlas textureAtlas = textureCache.getAtlasTexture();
        glActiveTexture(GL_TEXTURE0);
        textureAtlas.bind();

        // Itera sui chunk caricati e applica il culling a livello di chunk
        var loadedChunks = scene.getWorld().getLoadedChunks();
        for (var entry : loadedChunks.entrySet()) {
            var chunk = entry.getValue();
            // Calcola il bounding box del chunk
            float chunkMinX = chunk.getChunkX() * Chunk.WIDTH * Block.BLOCK_SIZE;
            float chunkMinY = 0; // Supponiamo che il chunk inizi sempre da 0 in Y
            float chunkMinZ = chunk.getChunkZ() * Chunk.DEPTH * Block.BLOCK_SIZE;
            float chunkMaxX = (chunk.getChunkX() + 1) * Chunk.WIDTH * Block.BLOCK_SIZE;
            float chunkMaxY = Chunk.HEIGHT * Block.BLOCK_SIZE;
            float chunkMaxZ = (chunk.getChunkZ() + 1) * Chunk.DEPTH * Block.BLOCK_SIZE;
            var chunkMin = new org.joml.Vector3f(chunkMinX, chunkMinY, chunkMinZ);
            var chunkMax = new org.joml.Vector3f(chunkMaxX, chunkMaxY, chunkMaxZ);

            // Se il chunk non è nel frustum, salta il rendering per questo chunk
            if (!scene.getCamera().getFrustum().isBoxInFrustum(chunkMin, chunkMax)) {
                continue;
            }

            // Per ogni modello, raggruppa gli entity appartenenti a questo chunk
            Collection<Model> models = scene.getModelMap().values();
            for (Model model : models) {
                List<Entity> entities = model.getEntitiesList();
                Map<org.joml.Vector4f, List<Entity>> grouped = new HashMap<>();
                for (Entity entity : entities) {
                    // Calcola il chunk di appartenenza dell'entity
                    int entityChunkX = (int) Math.floor(entity.getPosition().x / (Chunk.WIDTH * Block.BLOCK_SIZE));
                    int entityChunkZ = (int) Math.floor(entity.getPosition().z / (Chunk.DEPTH * Block.BLOCK_SIZE));
                    if (entityChunkX == chunk.getChunkX() && entityChunkZ == chunk.getChunkZ()) {
                        if (Block.isBlockVisible(scene, entity)) {
                            org.joml.Vector4f region = entity.getTextureRegion();
                            grouped.computeIfAbsent(region, k -> new ArrayList<>()).add(entity);
                        }
                    }
                }
                // Se nel modello ci sono entity appartenenti a questo chunk, esegui il
                // rendering
                if (!grouped.isEmpty()) {
                    for (Mesh mesh : model.getMeshList()) {
                        glBindVertexArray(mesh.getVaoId());
                        for (Map.Entry<org.joml.Vector4f, List<Entity>> groupEntry : grouped.entrySet()) {
                            for (Entity entity : groupEntry.getValue()) {
                                entity.updateModelMatrix();
                                uniformsMap.setUniform("modelMatrix", entity.getModelMatrix());
                                glDrawElements(GL_TRIANGLES, mesh.getNumVertices(), GL_UNSIGNED_INT, 0);
                            }
                        }
                        glBindVertexArray(0);
                    }
                }
            }
        }
        shaderProgram.unbind();
    }

    private void createUniforms() {
        uniformsMap = new UniformsMap(shaderProgram.getProgramId());
        uniformsMap.createUniform("projectionMatrix");
        uniformsMap.createUniform("modelMatrix");
        uniformsMap.createUniform("txtSampler");
        uniformsMap.createUniform("viewMatrix");
    }
}package scene;

import org.joml.Vector4f;
import graphics.Mesh;
import graphics.Model;
import graphics.Projection;
import graphics.TextureCacheAtlas;
import world.Block;
import world.Block.BlockType;
import world.Chunk;
import world.ChunkPosition;
import world.World;
import java.util.*;

public class Scene {
    private static TextureCacheAtlas textureCacheAtlas;
    private static Map<String, Model> modelMap;
    private static Map<String, Entity> entityMap;

    private static Projection projection;
    private static Camera camera;
    private static World world;

    // Aggiungi questi campi per memorizzare il chunk corrente del giocatore
    private int currentCenterChunkX = Integer.MIN_VALUE;
    private int currentCenterChunkZ = Integer.MIN_VALUE;

    // Cubo a 24 vertici (6 facce x 4 vertici)
    private static final float[] POSITIONS = {
            -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
            0.5f, 0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f,
            -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, -0.5f,
            -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f,
            -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f,
            0.5f, 0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f
    };

    private static final int[] INDICES = {
            0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11,
            12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
    };

    static {
        modelMap = new HashMap<>();
        entityMap = new HashMap<>();
    }

    public Scene(int width, int height) {
        projection = new Projection(width, height);
        camera = new Camera();
        textureCacheAtlas = new TextureCacheAtlas("textures/atlas.png", 256, 16);
    }

    public static void addEntity(Entity entity) {
        String modelId = entity.getModelId();
        Model model = modelMap.get(modelId);
        if (model == null)
            throw new RuntimeException("Modello non trovato: " + modelId);
        model.getEntitiesList().add(entity);
        entityMap.put(entity.getId(), entity);
    }

    public static void addModel(Model model) {
        modelMap.put(model.getId(), model);
    }

    public void cleanup() {
        modelMap.clear();
        entityMap.clear();
    }

    public Map<String, Model> getModelMap() {
        return modelMap;
    }

    public Projection getProjection() {
        return projection;
    }

    public void resize(int width, int height) {
        projection.updateProjMatrix(width, height);
    }

    public Camera getCamera() {
        return camera;
    }

    public static Entity createEntity(BlockType type) {
        String modelId = "block-model-" + type.name().toLowerCase();
        String entityId = "block-entity-" + type.name().toLowerCase() + "-" + System.currentTimeMillis();
        Model blockModel = modelMap.get(modelId);
        if (blockModel == null) {
            Vector4f textureRegion = textureCacheAtlas.getTextureRegion(type);
            float[] textCoords = generateUVCoordinates(textureRegion);
            Mesh mesh = new Mesh(POSITIONS, textCoords, INDICES);
            blockModel = new Model(modelId, List.of(mesh));
            addModel(blockModel);
        }
        Entity blockEntity = new Entity(entityId, blockModel.getId(), textureCacheAtlas.getTextureRegion(type));
        addEntity(blockEntity);
        return blockEntity;
    }

    /**
     * Cleanup di un chunk: per ogni blocco, se esiste un entity associato, lo
     * rimuove.
     */
    public void cleanupChunk(Chunk chunk) {
        Block[][][] blocks = chunk.getBlocks();
        for (int x = 0; x < blocks.length; x++) {
            for (int y = 0; y < blocks[x].length; y++) {
                for (int z = 0; z < blocks[x][y].length; z++) {
                    Block block = blocks[x][y][z];
                    if (block != null && block.getEntity() != null)
                        removeEntity(block.getEntity().getId());
                }
            }
        }
    }

    public void updateWorldGeneration(float playerX, float playerZ) {
        int newCenterChunkX = (int) Math.floor(playerX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int newCenterChunkZ = (int) Math.floor(playerZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        // Aggiorna i chunk solo se il giocatore è entrato in un nuovo chunk
        if (newCenterChunkX == currentCenterChunkX && newCenterChunkZ == currentCenterChunkZ) {
            return;
        }
        currentCenterChunkX = newCenterChunkX;
        currentCenterChunkZ = newCenterChunkZ;

        Map<ChunkPosition, Chunk> loadedChunks = world.getLoadedChunks();
        int renderDistance = world.getRenderDistance();
        Set<ChunkPosition> chunksToRemove = new HashSet<>();

        for (Map.Entry<ChunkPosition, Chunk> entry : loadedChunks.entrySet()) {
            ChunkPosition chunkPos = entry.getKey();
            int chunkDistanceX = Math.abs(chunkPos.getX() - currentCenterChunkX);
            int chunkDistanceZ = Math.abs(chunkPos.getZ() - currentCenterChunkZ);
            if (chunkDistanceX > renderDistance || chunkDistanceZ > renderDistance) {
                chunksToRemove.add(chunkPos);
            }
        }

        for (ChunkPosition posToRemove : chunksToRemove) {
            Chunk chunkToRemove = loadedChunks.get(posToRemove);
            if (chunkToRemove != null) {
                cleanupChunk(chunkToRemove);
            }
            loadedChunks.remove(posToRemove);
        }

        for (int dx = -renderDistance; dx <= renderDistance; dx++) {
            for (int dz = -renderDistance; dz <= renderDistance; dz++) {
                int chunkX = currentCenterChunkX + dx;
                int chunkZ = currentCenterChunkZ + dz;
                ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);
                if (!loadedChunks.containsKey(chunkPos)) {
                    Chunk chunk = new Chunk(chunkX, chunkZ);
                    loadedChunks.put(chunkPos, chunk);
                }
            }
        }
    }

    private static float[] generateUVCoordinates(Vector4f region) {
        float[] textCoords = new float[48]; // 6 facce * 4 vertici * 2 coordinate
        for (int face = 0; face < 6; face++) {
            int offset = face * 8;
            textCoords[offset] = region.x;
            textCoords[offset + 1] = region.y;
            textCoords[offset + 2] = region.x;
            textCoords[offset + 3] = region.w;
            textCoords[offset + 4] = region.z;
            textCoords[offset + 5] = region.w;
            textCoords[offset + 6] = region.z;
            textCoords[offset + 7] = region.y;
        }
        return textCoords;
    }

    public World getWorld() {
        return world;
    }

    public void setWorld(World worldd) {
        world = worldd;
    }

    public TextureCacheAtlas getTextureCacheAtlas() {
        return textureCacheAtlas;
    }

    public void removeEntity(String entityId) {
        Entity entity = entityMap.remove(entityId);
        if (entity == null)
            return;
        Model model = modelMap.get(entity.getModelId());
        if (model != null) {
            var list = model.getEntitiesList();
            int index = list.indexOf(entity);
            if (index != -1) {
                int last = list.size() - 1;
                list.set(index, list.get(last));
                list.remove(last);
            }
        }
    }
}package scene;

import org.joml.Matrix4f;
import org.joml.Vector3f;

public class Frustum {
    private Plane[] planes; // 6 piani che formano il frustum

    public Frustum() {
        planes = new Plane[6];
        for (int i = 0; i < 6; i++) {
            planes[i] = new Plane();
        }
    }

    /**
     * Aggiorna i piani del frustum combinando le matrici view e projection.
     */
    public void update(Matrix4f viewMatrix, Matrix4f projMatrix) {
        Matrix4f clipMatrix = new Matrix4f();
        projMatrix.mul(viewMatrix, clipMatrix);

        // Estrai il piano sinistro
        planes[0].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 0),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 0),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 0),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 0));
        planes[0].normalize();

        // Estrai il piano destro
        planes[1].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 0),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 0),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 0),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 0));
        planes[1].normalize();

        // Estrai il piano inferiore
        planes[2].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 1),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 1),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 1),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 1));
        planes[2].normalize();

        // Estrai il piano superiore
        planes[3].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 1),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 1),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 1),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 1));
        planes[3].normalize();

        // Estrai il piano near
        planes[4].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 2),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 2),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 2),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 2));
        planes[4].normalize();

        // Estrai il piano far
        planes[5].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 2),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 2),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 2),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 2));
        planes[5].normalize();
    }

    /**
     * Ritorna true se l'AABB (definito da min e max) è almeno parzialmente
     * all'interno del frustum.
     */
    public boolean isBoxInFrustum(Vector3f min, Vector3f max) {
        for (Plane plane : planes) {
            if (plane.classifyBox(min, max) == Plane.OUTSIDE) {
                return false;
            }
        }
        return true;
    }
}package scene;

import org.joml.*;
import java.lang.Math;

public class Camera {
    private Vector3f position, direction, right, up;
    private Vector2f rotation; // rotation.x = pitch, rotation.y = yaw
    private Matrix4f viewMatrix;
    private Frustum frustum;

    public Camera() {
        position = new Vector3f();
        direction = new Vector3f();
        right = new Vector3f();
        up = new Vector3f();
        rotation = new Vector2f();
        viewMatrix = new Matrix4f();
    }

    public void addRotation(float x, float y) {
        rotation.y += x;
        rotation.x += y;
        float pitchLimit = (float) Math.toRadians(89.0);
        if (rotation.x > pitchLimit)
            rotation.x = pitchLimit;
        if (rotation.x < -pitchLimit)
            rotation.x = -pitchLimit;
        recalculate();
    }

    public void moveForward(float inc) {
        viewMatrix.positiveZ(direction).negate().mul(inc);
        position.add(direction);
        recalculate();
    }

    public void moveBackwards(float inc) {
        viewMatrix.positiveZ(direction).negate().mul(inc);
        position.sub(direction);
        recalculate();
    }

    public void moveLeft(float inc) {
        viewMatrix.positiveX(right).mul(inc);
        position.sub(right);
        recalculate();
    }

    public void moveRight(float inc) {
        viewMatrix.positiveX(right).mul(inc);
        position.add(right);
        recalculate();
    }

    public void moveUp(float inc) {
        viewMatrix.positiveY(up).mul(inc);
        position.add(up);
        recalculate();
    }

    public void moveDown(float inc) {
        viewMatrix.positiveY(up).mul(inc);
        position.sub(up);
        recalculate();
    }

    private void recalculate() {
        viewMatrix.identity()
                .rotateX(rotation.x)
                .rotateY(rotation.y)
                .translate(-position.x, -position.y, -position.z);
    }

    public void setPosition(float x, float y, float z) {
        position.set(x, y, z);
        recalculate();
    }

    public Matrix4f getViewMatrix() {
        return viewMatrix;
    }

    public Vector3f getPosition() {
        return position;
    }

    public Frustum getFrustum() {
        if (frustum == null)
            frustum = new Frustum();
        return frustum;
    }
}package scene;

import org.joml.*;

public class Entity {
    private final String id;
    private final String modelId;
    private Matrix4f modelMatrix;
    private Vector4f textureRegion;
    private Vector3f position;
    private Quaternionf rotation;
    private float scale;

    public Entity(String id, String modelId, Vector4f textureRegion) {
        this.id = id;
        this.modelId = modelId;
        this.textureRegion = textureRegion;
        modelMatrix = new Matrix4f();
        position = new Vector3f();
        rotation = new Quaternionf();
        scale = 1;
    }

    public String getId() {
        return id;
    }

    public String getModelId() {
        return modelId;
    }

    public Matrix4f getModelMatrix() {
        return modelMatrix;
    }

    public Vector3f getPosition() {
        return position;
    }

    public Quaternionf getRotation() {
        return rotation;
    }

    public float getScale() {
        return scale;
    }

    public void setPosition(float x, float y, float z) {
        position.set(x, y, z);
    }

    public void setRotation(float x, float y, float z, float angle) {
        rotation.fromAxisAngleRad(x, y, z, angle);
    }

    public void setScale(float scale) {
        this.scale = scale;
    }

    public void updateModelMatrix() {
        modelMatrix.translationRotateScale(position, rotation, scale);
    }

    public Vector4f getTextureRegion() {
        return textureRegion;
    }

    public void setTextureRegion(Vector4f textureRegion) {
        this.textureRegion = textureRegion;
    }
}package scene;

import org.joml.Vector3f;

public class Plane {
    public static final int OUTSIDE = -1;
    private float a, b, c, d;

    public void set(float a, float b, float c, float d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    public void normalize() {
        float mag = (float) Math.sqrt(a * a + b * b + c * c);
        a /= mag;
        b /= mag;
        c /= mag;
        d /= mag;
    }

    public int classifyBox(Vector3f min, Vector3f max) {
        float px = (a >= 0) ? max.x : min.x;
        float py = (b >= 0) ? max.y : min.y;
        float pz = (c >= 0) ? max.z : min.z;
        if (a * px + b * py + c * pz + d < 0)
            return OUTSIDE;
        return 1;
    }
}package graphics;

import java.util.HashMap;
import java.util.Map;
import org.joml.Vector4f;
import world.Block.BlockType;

public class TextureCacheAtlas {
    private TextureAtlas atlas;
    private Map<String, float[]> uvCache;
    private Map<String, int[]> texturePositions;
    private Map<BlockType, Vector4f> textureRegionCache;

    public TextureCacheAtlas(String texturePath, int atlasSize, int tileSize) {
        atlas = new TextureAtlas(texturePath, atlasSize, tileSize);
        uvCache = new HashMap<>();
        texturePositions = initializeTexturePositions();
        textureRegionCache = new HashMap<>();
    }

    private Map<String, int[]> initializeTexturePositions() {
        Map<String, int[]> positions = new HashMap<>();
        positions.put("grass_top", new int[] { 1, 0 });
        positions.put("grass_side", new int[] { 3, 0 });
        positions.put("dirt", new int[] { 2, 0 });
        positions.put("stone", new int[] { 0, 4 });
        positions.put("wood", new int[] { 4, 1 });
        positions.put("default", new int[] { 0, 0 });
        return positions;
    }

    public TextureAtlas getAtlasTexture() {
        return atlas;
    }

    public void cleanup() {
        atlas.cleanup();
        uvCache.clear();
        texturePositions.clear();
        textureRegionCache.clear();
    }

    public Vector4f getTextureRegion(BlockType type) {
        return textureRegionCache.computeIfAbsent(type, t -> {
            String textureName = switch (t) {
                case GRASS -> "grass_top";
                case DIRT -> "dirt";
                case STONE -> "stone";
                case WOOD -> "wood";
                default -> "default";
            };
            if (!texturePositions.containsKey(textureName)) {
                System.err.println("Warning: Texture '" + textureName + "' not found. Using default.");
                textureName = "default";
            }
            int[] pos = texturePositions.get(textureName);
            float[] baseUV = atlas.getUVCoordinates(pos[0], pos[1]);
            return new Vector4f(baseUV[0], baseUV[1], baseUV[2], baseUV[3]);
        });
    }

    public float[] getUVCoordinates(String textureName) {
        if (!uvCache.containsKey(textureName)) {
            if (!texturePositions.containsKey(textureName)) {
                System.err.println("Warning: Texture '" + textureName + "' not found. Using default.");
                textureName = "default";
            }
            int[] pos = texturePositions.get(textureName);
            float[] baseUV = atlas.getUVCoordinates(pos[0], pos[1]);
            float[] formattedUV = new float[8];
            formattedUV[0] = baseUV[0];
            formattedUV[1] = baseUV[1];
            formattedUV[2] = baseUV[0];
            formattedUV[3] = baseUV[3];
            formattedUV[4] = baseUV[2];
            formattedUV[5] = baseUV[3];
            formattedUV[6] = baseUV[2];
            formattedUV[7] = baseUV[1];
            uvCache.put(textureName, formattedUV);
        }
        return uvCache.get(textureName);
    }
}package graphics;

import java.util.*;
import static org.lwjgl.opengl.GL20.*;
import utils.Utils;

public class ShaderProgram {
    private final int programId;

    public ShaderProgram(List<ShaderModuleData> modules) {
        programId = glCreateProgram();
        if (programId == 0)
            throw new RuntimeException("Could not create Shader Program");
        List<Integer> shaderModules = new ArrayList<>();
        for (ShaderModuleData s : modules) {
            shaderModules.add(createShader(Utils.readFile(s.shaderFile), s.shaderType));
        }
        link(shaderModules);
    }

    public void bind() {
        glUseProgram(programId);
    }

    public void unbind() {
        glUseProgram(0);
    }

    public void cleanup() {
        unbind();
        if (programId != 0)
            glDeleteProgram(programId);
    }

    public int getProgramId() {
        return programId;
    }

    protected int createShader(String code, int type) {
        int shaderId = glCreateShader(type);
        if (shaderId == 0)
            throw new RuntimeException("Error creating shader type: " + type);
        glShaderSource(shaderId, code);
        glCompileShader(shaderId);
        if (glGetShaderi(shaderId, GL_COMPILE_STATUS) == 0)
            throw new RuntimeException("Error compiling shader: " + glGetShaderInfoLog(shaderId, 1024));
        glAttachShader(programId, shaderId);
        return shaderId;
    }

    private void link(List<Integer> shaderModules) {
        glLinkProgram(programId);
        if (glGetProgrami(programId, GL_LINK_STATUS) == 0)
            throw new RuntimeException("Error linking Shader Program: " + glGetProgramInfoLog(programId, 1024));
        for (int shaderId : shaderModules) {
            glDetachShader(programId, shaderId);
            glDeleteShader(shaderId);
        }
    }

    public record ShaderModuleData(String shaderFile, int shaderType) {
    }
}package graphics;

import org.joml.Matrix4f;
import org.joml.Vector4f;
import org.lwjgl.system.MemoryStack;
import java.util.HashMap;
import java.util.Map;
import static org.lwjgl.opengl.GL20.*;

public class UniformsMap {
    private int programId;
    private Map<String, Integer> uniforms;

    public UniformsMap(int programId) {
        this.programId = programId;
        uniforms = new HashMap<>();
    }

    public void createUniform(String uniformName) {
        int location = glGetUniformLocation(programId, uniformName);
        if (location < 0)
            throw new RuntimeException("Could not find uniform: " + uniformName);
        uniforms.put(uniformName, location);
    }

    private int getUniformLocation(String name) {
        Integer loc = uniforms.get(name);
        if (loc == null)
            throw new RuntimeException("Uniform not found: " + name);
        return loc;
    }

    public void setUniform(String name, int value) {
        glUniform1i(getUniformLocation(name), value);
    }

    public void setUniform(String name, Matrix4f value) {
        try (MemoryStack stack = MemoryStack.stackPush()) {
            glUniformMatrix4fv(getUniformLocation(name), false, value.get(stack.mallocFloat(16)));
        }
    }

    public void setUniform(String name, Vector4f value) {
        glUniform4f(getUniformLocation(name), value.x, value.y, value.z, value.w);
    }
}package graphics;

import org.joml.Matrix4f;

public class Projection {
    private static final float FOV = (float) Math.toRadians(60.0);
    private static final float Z_NEAR = 0.01f;
    private static final float Z_FAR = 1000f;
    private Matrix4f projMatrix;

    public Projection(int width, int height) {
        projMatrix = new Matrix4f();
        updateProjMatrix(width, height);
    }

    public Matrix4f getProjMatrix() {
        return projMatrix;
    }

    public void updateProjMatrix(int width, int height) {
        projMatrix.setPerspective(FOV, (float) width / height, Z_NEAR, Z_FAR);
    }
}package graphics;

import org.lwjgl.opengl.GL30;
import org.lwjgl.system.MemoryUtil;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.List;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL15.*;
import static org.lwjgl.opengl.GL20.*;
import static org.lwjgl.opengl.GL30.*;

public class Mesh {
    private int numVertices;
    private int vaoId;
    private List<Integer> vboIdList;

    public Mesh(float[] positions, float[] textCoords, int[] indices) {
        numVertices = indices.length;
        vboIdList = new ArrayList<>();
        vaoId = glGenVertexArrays();
        glBindVertexArray(vaoId);
        // Positions VBO
        int vboId = glGenBuffers();
        vboIdList.add(vboId);
        FloatBuffer posBuffer = MemoryUtil.memAllocFloat(positions.length);
        posBuffer.put(positions).flip();
        glBindBuffer(GL_ARRAY_BUFFER, vboId);
        glBufferData(GL_ARRAY_BUFFER, posBuffer, GL_STATIC_DRAW);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);
        // Texture Coordinates VBO
        vboId = glGenBuffers();
        vboIdList.add(vboId);
        FloatBuffer texBuffer = MemoryUtil.memAllocFloat(textCoords.length);
        texBuffer.put(textCoords).flip();
        glBindBuffer(GL_ARRAY_BUFFER, vboId);
        glBufferData(GL_ARRAY_BUFFER, texBuffer, GL_STATIC_DRAW);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 2, GL_FLOAT, false, 0, 0);
        // Indices VBO
        vboId = glGenBuffers();
        vboIdList.add(vboId);
        IntBuffer indicesBuffer = MemoryUtil.memAllocInt(indices.length);
        indicesBuffer.put(indices).flip();
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboId);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesBuffer, GL_STATIC_DRAW);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
        MemoryUtil.memFree(posBuffer);
        MemoryUtil.memFree(texBuffer);
        MemoryUtil.memFree(indicesBuffer);
    }

    public void cleanup() {
        vboIdList.forEach(GL30::glDeleteBuffers);
        glDeleteVertexArrays(vaoId);
    }

    public int getNumVertices() {
        return numVertices;
    }

    public int getVaoId() {
        return vaoId;
    }
}package graphics;

import static org.lwjgl.opengl.GL11.*;
import core.Window;
import scene.Scene;
import scene.SceneRender;

public class Render {
    private SceneRender sceneRender;

    public Render() {
        org.lwjgl.opengl.GL.createCapabilities();
        glEnable(GL_DEPTH_TEST);
        sceneRender = new SceneRender();
    }

    public void cleanup() {
        sceneRender.cleanup();
    }

    public void render(Window window, Scene scene) {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glViewport(0, 0, window.getWidth(), window.getHeight());
        sceneRender.render(window, scene);
    }
}package graphics;

import org.lwjgl.BufferUtils;
import org.lwjgl.system.MemoryStack;
import core.Main;
import java.io.IOException;
import java.io.InputStream;
import java.nio.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.stb.STBImage.*;

public class TextureAtlas {
    private int textureId;
    private int atlasSize;
    private int tileSize;
    private String texturePath;

    public TextureAtlas(String texturePath, int atlasSize, int tileSize) {
        this.texturePath = texturePath;
        this.atlasSize = atlasSize;
        this.tileSize = tileSize;
        try (MemoryStack stack = MemoryStack.stackPush()) {
            InputStream in = Main.class.getClassLoader().getResourceAsStream(texturePath);
            if (in == null) {
                throw new RuntimeException("Texture not found: " + texturePath);
            }
            byte[] bytes = in.readAllBytes();
            ByteBuffer imageBuffer = BufferUtils.createByteBuffer(bytes.length);
            imageBuffer.put(bytes).flip();
            IntBuffer w = stack.mallocInt(1), h = stack.mallocInt(1), channels = stack.mallocInt(1);
            ByteBuffer buf = stbi_load_from_memory(imageBuffer, w, h, channels, 4);
            if (buf == null) {
                throw new RuntimeException("Failed to load texture: " + stbi_failure_reason());
            }
            int width = w.get();
            int height = h.get();
            generateTexture(width, height, buf);
            stbi_image_free(buf);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void generateTexture(int width, int height, ByteBuffer buf) {
        textureId = glGenTextures();
        glBindTexture(GL_TEXTURE_2D, textureId);
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    public void bind() {
        glBindTexture(GL_TEXTURE_2D, textureId);
    }

    public void cleanup() {
        glDeleteTextures(textureId);
    }

    public float[] getUVCoordinates(int x, int y) {
        float halfPixel = 0.5f / atlasSize;
        float uMin = (x * tileSize + halfPixel) / atlasSize;
        float vMin = (y * tileSize + halfPixel) / atlasSize;
        float uMax = (((x + 1) * tileSize) - halfPixel) / atlasSize;
        float vMax = (((y + 1) * tileSize) - halfPixel) / atlasSize;
        return new float[] { uMin, vMin, uMax, vMax };
    }

    public String getTexturePath() {
        return texturePath;
    }
}package graphics;

import java.util.ArrayList;
import java.util.List;
import scene.Entity;

public class Model {
    private final String id;
    private List<Entity> entitiesList;
    private List<Mesh> meshList;

    public Model(String id, List<Mesh> meshList) {
        this.id = id;
        this.meshList = meshList;
        this.entitiesList = new ArrayList<>();
    }

    public List<Entity> getEntitiesList() {
        return entitiesList;
    }

    public String getId() {
        return id;
    }

    public List<Mesh> getMeshList() {
        return meshList;
    }
}package entities;

public class Mob {
    
}
package entities;

public class Player {
    
}
package entities;

public class Entity {
    
}
