package ui;

public class Menu {
    
}
package ui;

public class HUD {
    
}
package core;

import graphics.Render;
import scene.Scene;

public interface IAppLogic {

    void cleanup();

    void init(Window window, Scene scene, Render render);

    void input(Window window, Scene scene, float diffTimeMillis);

    void update(Window window, Scene scene, long diffTimeMillis);
}
package core;

import org.joml.Vector2f;
import static org.lwjgl.glfw.GLFW.*;

public class MouseInput {

    private Vector2f currentPos;
    private Vector2f displVec;
    private Vector2f previousPos;

    private boolean leftButtonPressed;
    private boolean rightButtonPressed;

    public MouseInput(long windowHandle) {
        // Disabilita il cursore per catturare il movimento relativo (comportamento in
        // stile Minecraft)
        glfwSetInputMode(windowHandle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

        previousPos = new Vector2f(-1, -1);
        currentPos = new Vector2f();
        displVec = new Vector2f();
        leftButtonPressed = false;
        rightButtonPressed = false;

        // Imposta il callback per la posizione del mouse
        glfwSetCursorPosCallback(windowHandle, (handle, xpos, ypos) -> {
            currentPos.x = (float) xpos;
            currentPos.y = (float) ypos;
        });

        // Imposta il callback per i pulsanti del mouse
        glfwSetMouseButtonCallback(windowHandle, (handle, button, action, mode) -> {
            leftButtonPressed = button == GLFW_MOUSE_BUTTON_1 && action == GLFW_PRESS;
            rightButtonPressed = button == GLFW_MOUSE_BUTTON_2 && action == GLFW_PRESS;
        });
    }

    public Vector2f getCurrentPos() {
        return currentPos;
    }

    public Vector2f getDisplVec() {
        return displVec;
    }

    public void input() {
        displVec.x = 0;
        displVec.y = 0;

        // Se è la prima volta o il mouse è appena entrato nella finestra
        if (previousPos.x < 0 || previousPos.y < 0) {
            previousPos.x = currentPos.x;
            previousPos.y = currentPos.y;
            return;
        }

        // Calcola la variazione di movimento del mouse
        displVec.x = currentPos.x - previousPos.x; // movimento orizzontale (yaw)
        displVec.y = currentPos.y - previousPos.y; // movimento verticale (pitch)

        // Aggiorna la posizione precedente
        previousPos.x = currentPos.x;
        previousPos.y = currentPos.y;
    }

    public boolean isLeftButtonPressed() {
        return leftButtonPressed;
    }

    public boolean isRightButtonPressed() {
        return rightButtonPressed;
    }
}package core;

import org.lwjgl.glfw.GLFWErrorCallback;
import org.lwjgl.glfw.GLFWVidMode;

import java.util.concurrent.Callable;

import static org.lwjgl.glfw.Callbacks.glfwFreeCallbacks;
import static org.lwjgl.glfw.GLFW.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.system.MemoryUtil.NULL;

public class Window {
    private final long windowHandle;
    private int height;
    private int width;
    private String title;
    
    private Callable<Void> resizeFunc;
    private MouseInput mouseInput;

    public static class WindowOptions {
        public boolean compatibleProfile;
        public int fps;
        public int height;
        public int ups = Engine.TARGET_UPS;
        public int width;
    }

    public Window(String title, WindowOptions opts, Callable<Void> resizeFunc) {
        this.resizeFunc = resizeFunc;
        this.title = title;
        if (!glfwInit()) {
            throw new IllegalStateException("Unable to initialize GLFW");
        }

        glfwDefaultWindowHints();
        glfwWindowHint(GLFW_VISIBLE, GL_FALSE);
        glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);

        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);
        if (opts.compatibleProfile) {
            glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_COMPAT_PROFILE);
        } else {
            glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
            glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
        }

        if (opts.width > 0 && opts.height > 0) {
            this.width = opts.width;
            this.height = opts.height;
        } else {
            glfwWindowHint(GLFW_MAXIMIZED, GLFW_TRUE);
            GLFWVidMode vidMode = glfwGetVideoMode(glfwGetPrimaryMonitor());
            width = vidMode.width();
            height = vidMode.height();
        }

        windowHandle = glfwCreateWindow(width, height, title, NULL, NULL);
        if (windowHandle == NULL) {
            throw new RuntimeException("Failed to create the GLFW window");
        }

        glfwSetFramebufferSizeCallback(windowHandle, (window, w, h) -> resized(w, h));

        /*
         * glfwSetErrorCallback((int errorCode, long msgPtr) ->
         * Logger.error("Error code [{}], msg [{}]", errorCode,
         * MemoryUtil.memUTF8(msgPtr))
         * );
         */

        glfwSetKeyCallback(windowHandle, (window, key, scancode, action, mods) -> {
            keyCallBack(key, action);
        });

        glfwMakeContextCurrent(windowHandle);

        if (opts.fps > 0) {
            glfwSwapInterval(0);
        } else {
            glfwSwapInterval(1);
        }

        glfwShowWindow(windowHandle);

        int[] arrWidth = new int[1];
        int[] arrHeight = new int[1];
        glfwGetFramebufferSize(windowHandle, arrWidth, arrHeight);
        width = arrWidth[0];
        height = arrHeight[0];
        mouseInput = new MouseInput(windowHandle);
    }

    public void keyCallBack(int key, int action) {
        if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {
            glfwSetWindowShouldClose(windowHandle, true);
        }
    }

    public void cleanup() {
        glfwFreeCallbacks(windowHandle);
        glfwDestroyWindow(windowHandle);
        glfwTerminate();
        GLFWErrorCallback callback = glfwSetErrorCallback(null);
        if (callback != null) {
            callback.free();
        }
    }

    public int getHeight() {
        return height;
    }

    public int getWidth() {
        return width;
    }

    public long getWindowHandle() {
        return windowHandle;
    }

    public boolean isKeyPressed(int keyCode) {
        return glfwGetKey(windowHandle, keyCode) == GLFW_PRESS;
    }

    public void pollEvents() {
        glfwPollEvents();
    }

    protected void resized(int width, int height) {
        this.width = width;
        this.height = height;
        try {
            resizeFunc.call();
        } catch (Exception excp) {
            // Logger.error("Error calling resize callback", excp);
        }
    }

    public void update() {
        glfwSwapBuffers(windowHandle);
    }

    public boolean windowShouldClose() {
        return glfwWindowShouldClose(windowHandle);
    }

    public MouseInput getMouseInput() {
        return mouseInput;
    }

    public void setTitle(String title) {
        this.title = title;
        glfwSetWindowTitle(windowHandle, title);
    }

    public String getTitle() {
        return title;
    }
}package core;

public class Timer {
    
}
package core;

import graphics.Render;
import scene.Scene;

public class Engine {
    public static final int TARGET_UPS = 30;
    private final IAppLogic appLogic;
    private final Window window;
    private Render render;
    private Scene scene;
    private boolean running;
    private int targetFps;
    private int targetUps;

    public Engine(String windowTitle, Window.WindowOptions opts, IAppLogic appLogic) {
        window = new Window(windowTitle, opts, () -> {
            resize();
            return null;
        });
        targetFps = opts.fps;
        targetUps = opts.ups;
        render = new Render();
        scene = new Scene(window.getWidth(), window.getHeight());

        this.appLogic = appLogic;
        this.appLogic.init(window, scene, render);
        running = true;
    }

    private void cleanup() {
        appLogic.cleanup();
        window.cleanup();
        render.cleanup();
        scene.cleanup();
    }

    private void resize() {
        scene.resize(window.getWidth(), window.getHeight());
    }

    private void run() {
        long initialTime = System.nanoTime(); // Usa nanoTime per la precisione in nanosecondi
        float timeU = 1e9f / targetUps; // Tempo per aggiornamento in nanosecondi
        float timeR = targetFps > 0 ? 1e9f / targetFps : 0; // Tempo per frame in nanosecondi
        float deltaUpdate = 0;
        float deltaFps = 0;

        int fps = 0;
        int fpsCount = 0;
        long fpsTime = System.nanoTime(); // Usa nanoTime per il conteggio degli FPS

        long updateTime = initialTime;
        while (running && !window.windowShouldClose()) {
            window.pollEvents();

            long now = System.nanoTime(); // Ottieni il tempo corrente in nanosecondi
            long deltaTime = now - initialTime; // Differenza di tempo in nanosecondi
            deltaUpdate += deltaTime / timeU; // Calcola deltaUpdate
            deltaFps += deltaTime / timeR; // Calcola deltaFps

            if (targetFps <= 0 || deltaFps >= 1) {
                window.getMouseInput().input();
                appLogic.input(window, scene, deltaTime / 1e6f); // Converti in millisecondi per l'input
            }

            if (deltaUpdate >= 1) {
                long diffTimeMillis = (now - updateTime) / 1000000L; // Calcola la differenza in millisecondi
                appLogic.update(window, scene, diffTimeMillis);
                updateTime = now;
                deltaUpdate--;
            }

            if (targetFps <= 0 || deltaFps >= 1) {
                render.render(window, scene);
                window.update();

                // Incrementa il contatore dei frame
                fpsCount++;

                // Aggiorna il valore degli FPS ogni secondo
                if (now - fpsTime >= 1e9) { // 1 secondo in nanosecondi
                    fps = fpsCount;
                    fpsCount = 0;
                    fpsTime = now;
                }
            }
            initialTime = now;

            String baseTitle = "Minecraft ";
            window.setTitle(baseTitle + " | FPS: " + fps);
        }

        cleanup();
    }

    public void start() {
        running = true;
        run();
    }

    public void stop() {
        running = false;
    }
}
package core;

import static org.lwjgl.glfw.GLFW.GLFW_KEY_A;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_D;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_LEFT_CONTROL;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_S;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_SPACE;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_W;

import org.joml.Vector2f;

import graphics.Render;
import scene.Camera;
import scene.Scene;
import world.World;

public class Main implements IAppLogic {

    private static final float MOUSE_SENSITIVITY = 0.1f;
    private static final float MOVEMENT_SPEED = 0.005f;

    public static void main(String[] args) {
        Main main = new Main();
        Engine gameEng = new Engine("Minecraft ", new Window.WindowOptions(), main);
        gameEng.start();
    }

    @Override
    public void cleanup() {
        // Nothing to be done yet
    }

    @Override
    public void init(Window window, Scene scene, Render render) {
        scene.setWorld(new World());
        scene.getWorld().generateInitialWorld(0, 0);
        scene.getCamera().setPosition(0f, 75f, 0f);
        System.out.println("World generated");
    }

    @Override
    public void input(Window window, Scene scene, float diffTimeMillis) {
        float move = diffTimeMillis * MOVEMENT_SPEED;
        Camera camera = scene.getCamera();
        MouseInput mouseInput = window.getMouseInput();
        Vector2f displVec = mouseInput.getDisplVec();
        if (window.isKeyPressed(GLFW_KEY_W)) {
            camera.moveForward(move);
        } else if (window.isKeyPressed(GLFW_KEY_S)) {
            camera.moveBackwards(move);
        }
        if (window.isKeyPressed(GLFW_KEY_A)) {
            camera.moveLeft(move);
        } else if (window.isKeyPressed(GLFW_KEY_D)) {
            camera.moveRight(move);
        }
        if (window.isKeyPressed(GLFW_KEY_SPACE)) {
            camera.moveUp(move);
        } else if (window.isKeyPressed(GLFW_KEY_LEFT_CONTROL)) {
            camera.moveDown(move);
        }
        
        camera.addRotation(
                (float) Math.toRadians(displVec.x * MOUSE_SENSITIVITY),
                (float) Math.toRadians(displVec.y * MOUSE_SENSITIVITY));
    }

    @Override
    public void update(Window window, Scene scene, long diffTimeMillis) {
        float playerX = scene.getCamera().getPosition().x;
        float playerZ = scene.getCamera().getPosition().z;
        scene.updateWorldGeneration(playerX, playerZ);
    }
}
package core;

public class Settings {
    
}
package world;

import java.util.Objects;

public class ChunkPosition {
    int x, z;

    public ChunkPosition(int x, int z) {
        this.x = x;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        ChunkPosition that = (ChunkPosition) o;
        return x == that.x && z == that.z;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, z);
    }


    public int getX() {
        return this.x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getZ() {
        return this.z;
    }

    public void setZ(int z) {
        this.z = z;
    }

}
package world;

import java.util.HashMap;
import java.util.Map;

public class World {
    private Map<ChunkPosition, Chunk> loadedChunks;
    private int renderDistance = 1;

    public World() {
        this.loadedChunks = new HashMap<>();
    }

    public void generateInitialWorld(float centerX, float centerZ) {
        int centerChunkX = (int) Math.floor(centerX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int centerChunkZ = (int) Math.floor(centerZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        for (int dx = -renderDistance; dx <= renderDistance; dx++) {
            for (int dz = -renderDistance; dz <= renderDistance; dz++) {
                int chunkX = centerChunkX + dx;
                int chunkZ = centerChunkZ + dz;

                ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);

                if (!loadedChunks.containsKey(chunkPos)) {
                    // Passa il textureCache al costruttore di Chunk
                    Chunk chunk = new Chunk(chunkX, chunkZ);
                    loadedChunks.put(chunkPos, chunk);
                }
            }
        }
    }

    public void setBlockAtWorldPosition(float worldX, float worldY, float worldZ, Block.BlockType blockType) {
        int chunkX = (int) Math.floor(worldX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int chunkZ = (int) Math.floor(worldZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        int localX = (int) Math.floor((worldX % (Chunk.WIDTH * Block.BLOCK_SIZE)) / Block.BLOCK_SIZE);
        int localY = (int) Math.floor(worldY / Block.BLOCK_SIZE);
        int localZ = (int) Math.floor((worldZ % (Chunk.DEPTH * Block.BLOCK_SIZE)) / Block.BLOCK_SIZE);

        ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);
        Chunk chunk = loadedChunks.get(chunkPos);

        if (chunk != null) {
            Block newBlock = new Block(blockType);
            newBlock.setWorldPosition(worldX, worldY, worldZ);
            chunk.setBlock(localX, localY, localZ, newBlock);
        }
    }

    public Map<ChunkPosition, Chunk> getLoadedChunks() {
        return loadedChunks;
    }

    public Block getBlock(int x, int y, int z) {
        // Trova il chunk che contiene queste coordinate
        int chunkX = x >> 4; // Dividi per 16
        int chunkZ = z >> 4;

        Chunk chunk = getChunk(chunkX, chunkZ);
        if (chunk == null) {
            return null;
        }

        // Trova il blocco all'interno del chunk
        return chunk.getBlock(x & 15, y, z & 15);
    }

    public Chunk getChunk(int chunkX, int chunkZ) {
        ChunkPosition position = new ChunkPosition(chunkX, chunkZ);
        return loadedChunks.get(position);
    }

    public int getRenderDistance() {
        return renderDistance;
    }
}package world;

public class Chunk {
    public static final int WIDTH = 16;
    public static final int HEIGHT = 256;
    public static final int DEPTH = 16;

    private final int chunkX;
    private final int chunkZ;
    private Block[][][] blocks;
    private boolean isDirty;

    public Chunk(int chunkX, int chunkZ) {
        this.chunkX = chunkX;
        this.chunkZ = chunkZ;
        this.blocks = new Block[WIDTH][HEIGHT][DEPTH];
        this.isDirty = true;
        System.out.println("Generating Chunk at: " + chunkX + ", " + chunkZ);

        generateInitialTerrain();
    }

    private void generateInitialTerrain() {
        // Ciclo corretto: x da 0 a WIDTH, z da 0 a DEPTH, y da 0 a HEIGHT.
        for (int x = 0; x < WIDTH; x++) {
            for (int z = 0; z < DEPTH; z++) { // Usa DEPTH qui!
                int terrainHeight = calculateTerrainHeight(x, z);

                for (int y = 0; y < HEIGHT; y++) { // Usa HEIGHT per la verticale
                    Block.BlockType blockType = determineBlockType(x, y, z, terrainHeight);

                    if (blockType != Block.BlockType.AIR) {
                        float worldX = (chunkX * WIDTH + x) * Block.BLOCK_SIZE;
                        float worldY = y * Block.BLOCK_SIZE;
                        float worldZ = (chunkZ * DEPTH + z) * Block.BLOCK_SIZE;

                        Block block = new Block(blockType);
                        block.setWorldPosition(worldX, worldY, worldZ);

                        setBlock(x, y, z, block);
                    }
                }
            }
        }
    }

    private int calculateTerrainHeight(int localX, int localZ) {
        double noise1 = Math.sin(localX * 0.1) * 10;
        double noise2 = Math.cos(localZ * 0.2) * 8;
        double noise3 = Math.sin(localX * 0.05 + localZ * 0.05) * 15;

        return 64 + (int) (noise1 + noise2 + noise3);
        //return 4;
    }

    private Block.BlockType determineBlockType(int x, int y, int z, int terrainHeight) {
        if (y == 0)
            return Block.BlockType.STONE;
        if (y < terrainHeight - 3)
            return Block.BlockType.STONE;
        if (y < terrainHeight - 1)
            return Block.BlockType.STONE;
        if (y < terrainHeight)
            return Block.BlockType.GRASS;
        return Block.BlockType.AIR;
    }

    public void setBlock(int x, int y, int z, Block block) {
        if (isValidPosition(x, y, z)) {
            blocks[x][y][z] = block;
            isDirty = true;
        }
    }

    public Block getBlock(int x, int y, int z) {
        return isValidPosition(x, y, z) ? blocks[x][y][z] : null;
    }

    private boolean isValidPosition(int x, int y, int z) {
        return x >= 0 && x < WIDTH &&
                y >= 0 && y < HEIGHT &&
                z >= 0 && z < DEPTH;
    }

    public boolean isDirty() {
        return isDirty;
    }

    public void resetDirtyFlag() {
        isDirty = false;
    }

    public int getChunkX() {
        return chunkX;
    }

    public int getChunkZ() {
        return chunkZ;
    }

    public Block[][][] getBlocks() {
        return blocks;
    }
}package world;

import org.joml.Vector3f;

import scene.Camera;
import scene.Entity;
import scene.Scene;

public class Block {
    public static final float BLOCK_SIZE = 1.0f;
    private Entity blockEntity;
    private BlockType type;

    public enum BlockType {
        AIR,
        GRASS,
        DIRT,
        STONE,
        WOOD
    }

    public enum Face {
        TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT
    }

    public Block(BlockType type) {
        this.type = type;
        this.blockEntity = Scene.createEntity(type);
    }

    public void setWorldPosition(float x, float y, float z) {
        blockEntity.setPosition(x, y, z);
    }

    public Entity getEntity() {
        return blockEntity;
    }

    public BlockType getType() {
        return type;
    }

    public boolean isSolid() {
        return type != BlockType.AIR;
    }

    public void updateModelMatrix() {
        blockEntity.updateModelMatrix();
    }

    public static boolean isBlockVisible(Scene scene, Entity entity) {
        Camera camera = scene.getCamera();

        // 1. Frustum Culling - verifica se il blocco è nel campo visivo della camera
        if (!isInFrustum(camera, entity)) {
            return false;
        }

        // 2. Distance Culling - ignora blocchi troppo lontani
        float maxDistance = 100.0f; // Distanza massima di rendering
        Vector3f cameraPos = camera.getPosition();
        Vector3f blockPos = entity.getPosition();

        float distSquared = cameraPos.distanceSquared(blockPos);
        if (distSquared > maxDistance * maxDistance) {
            return false;
        }

        // 3. Occlusion Culling - verifica se il blocco è coperto
        // Questo è più complesso - implementazione semplificata
        if (isOccluded(scene, entity)) {
            return false;
        }

        return true;
    }

    /**
     * Verifica se un blocco è all'interno del frustum della camera
     */
    private static boolean isInFrustum(Camera camera, Entity entity) {
        // Ottieni le dimensioni dell'AABB del blocco (Axis-Aligned Bounding Box)
        Vector3f position = entity.getPosition();
        Vector3f min = new Vector3f(position.x - BLOCK_SIZE / 2,
                position.y - BLOCK_SIZE / 2,
                position.z - BLOCK_SIZE / 2);
        Vector3f max = new Vector3f(position.x + BLOCK_SIZE / 2,
                position.y + BLOCK_SIZE / 2,
                position.z + BLOCK_SIZE / 2);

        // Controlla se l'AABB è all'interno del frustum
        return camera.getFrustum().isBoxInFrustum(min, max);
    }

    /**
     * Verifica se un blocco è completamente coperto da altri blocchi
     * Questa è un'implementazione semplificata
     */
    private static boolean isOccluded(Scene scene, Entity entity) {
        // Implementazione semplice: un blocco è occluso se tutti i 6 lati sono coperti
        // da altri blocchi opachi (non trasparenti come vetro, acqua, ecc.)

        World world = scene.getWorld();
        Vector3f pos = entity.getPosition();
        int x = Math.round(pos.x);
        int y = Math.round(pos.y);
        int z = Math.round(pos.z);

        // Verifica tutti i 6 lati adiacenti
        boolean allSidesCovered = true;

        // Direzioni: su, giù, nord, sud, est, ovest
        int[][] directions = {
                { 0, 1, 0 }, { 0, -1, 0 }, { 0, 0, 1 }, { 0, 0, -1 }, { 1, 0, 0 }, { -1, 0, 0 }
        };

        for (int[] dir : directions) {
            Block adjacent = world.getBlock(x + dir[0], y + dir[1], z + dir[2]);
            if (adjacent == null || !adjacent.isOpaque()) {
                allSidesCovered = false;
                break;
            }
        }

        return allSidesCovered;
    }

    private boolean isOpaque() {
        return type != BlockType.AIR;
    }
}
package utils;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

import core.Main;

public class Utils {

    public static String readFile(String filePath) {
        String str = null;

        try {
            InputStream inputStream = readFromClasspath(filePath);

            if (inputStream == null) {
                inputStream = new FileInputStream(filePath);
            }

            str = new String(inputStream.readAllBytes());
            inputStream.close();
        } catch (IOException excp) {
            throw new RuntimeException("Error reading file [" + filePath + "]", excp);
        }

        return str;
    }

    private static InputStream readFromClasspath(String filePath) {
        return Main.class.getClassLoader().getResourceAsStream(filePath);
    }

}
package audio;

public class SoundManager {
    
}
package physics;

public class Gravity {
    
}
package physics;

public class Collision {
    
}
package scene;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.joml.Vector4f;
import core.Window;
import graphics.Mesh;
import graphics.Model;
import graphics.ShaderProgram;
import graphics.TextureAtlas;
import graphics.TextureCacheAtlas;
import graphics.UniformsMap;
import world.Block;

import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL13.*;
import static org.lwjgl.opengl.GL20.*;
import static org.lwjgl.opengl.GL30.*;

public class SceneRender {

    private ShaderProgram shaderProgram;
    private UniformsMap uniformsMap;

    public SceneRender() {
        List<ShaderProgram.ShaderModuleData> shaderModuleDataList = new ArrayList<>();
        shaderModuleDataList.add(new ShaderProgram.ShaderModuleData("shaders/scene.vert", GL_VERTEX_SHADER));
        shaderModuleDataList.add(new ShaderProgram.ShaderModuleData("shaders/scene.frag", GL_FRAGMENT_SHADER));
        shaderProgram = new ShaderProgram(shaderModuleDataList);
        createUniforms();
    }

    public void cleanup() {
        shaderProgram.cleanup();
    }

    public void render(Window window, Scene scene) {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glViewport(0, 0, window.getWidth(), window.getHeight());

        // Aggiorna il frustum una sola volta per frame
        scene.getCamera().getFrustum().update(scene.getCamera().getViewMatrix(), scene.getProjection().getProjMatrix());

        shaderProgram.bind();
        uniformsMap.setUniform("projectionMatrix", scene.getProjection().getProjMatrix());
        uniformsMap.setUniform("viewMatrix", scene.getCamera().getViewMatrix());
        uniformsMap.setUniform("txtSampler", 0);

        TextureCacheAtlas textureCache = scene.getTextureCacheAtlas();
        TextureAtlas textureAtlas = textureCache.getAtlasTexture();
        glActiveTexture(GL_TEXTURE0);
        textureAtlas.bind();

        Collection<Model> models = scene.getModelMap().values();
        for (Model model : models) {
            List<Entity> entities = model.getEntitiesList();
            // Raggruppa le entità per texture region solo se sono visibili
            Map<Vector4f, List<Entity>> entitiesByTextureRegion = new HashMap<>();
            for (Entity entity : entities) {
                if (Block.isBlockVisible(scene, entity)) {
                    Vector4f region = entity.getTextureRegion();
                    entitiesByTextureRegion.computeIfAbsent(region, k -> new ArrayList<>()).add(entity);
                }
            }
            for (Mesh mesh : model.getMeshList()) {
                glBindVertexArray(mesh.getVaoId());
                for (Map.Entry<Vector4f, List<Entity>> entry : entitiesByTextureRegion.entrySet()) {
                    List<Entity> entitiesWithSameTexture = entry.getValue();
                    for (Entity entity : entitiesWithSameTexture) {
                        entity.updateModelMatrix();
                        uniformsMap.setUniform("modelMatrix", entity.getModelMatrix());
                        glDrawElements(GL_TRIANGLES, mesh.getNumVertices(), GL_UNSIGNED_INT, 0);
                    }
                }
                glBindVertexArray(0);
            }
        }
        shaderProgram.unbind();
    }

    private void createUniforms() {
        uniformsMap = new UniformsMap(shaderProgram.getProgramId());
        uniformsMap.createUniform("projectionMatrix");
        uniformsMap.createUniform("modelMatrix");
        uniformsMap.createUniform("txtSampler");
        uniformsMap.createUniform("viewMatrix");
    }
}package scene;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.joml.Vector4f;

import graphics.Mesh;
import graphics.Model;
import graphics.Projection;
import graphics.TextureCacheAtlas;
import world.Block;
import world.Block.BlockType;
import world.Chunk;
import world.ChunkPosition;
import world.World;

public class Scene {

    // Texture cache e mapping dei modelli (static per condivisione globale)
    private static TextureCacheAtlas textureCacheAtlas;
    private static Map<String, Model> modelMap;
    // Mappa globale per avere accesso diretto agli entity tramite ID
    private static Map<String, Entity> entityMap;

    private static Projection projection;
    private static Camera camera;
    private static World world;

    // Array di vertici e indici per un cubo a 24 vertici (6 facce x 4 vertici)
    private static final float[] POSITIONS = new float[] {
            // Front face
            -0.5f, 0.5f, 0.5f, // 0: top-left
            -0.5f, -0.5f, 0.5f, // 1: bottom-left
            0.5f, -0.5f, 0.5f, // 2: bottom-right
            0.5f, 0.5f, 0.5f, // 3: top-right

            // Back face
            0.5f, 0.5f, -0.5f, // 4: top-left
            0.5f, -0.5f, -0.5f, // 5: bottom-left
            -0.5f, -0.5f, -0.5f, // 6: bottom-right
            -0.5f, 0.5f, -0.5f, // 7: top-right

            // Top face
            -0.5f, 0.5f, -0.5f, // 8: top-left
            -0.5f, 0.5f, 0.5f, // 9: bottom-left
            0.5f, 0.5f, 0.5f, // 10: bottom-right
            0.5f, 0.5f, -0.5f, // 11: top-right

            // Bottom face
            -0.5f, -0.5f, 0.5f, // 12: top-left
            -0.5f, -0.5f, -0.5f, // 13: bottom-left
            0.5f, -0.5f, -0.5f, // 14: bottom-right
            0.5f, -0.5f, 0.5f, // 15: top-right

            // Left face
            -0.5f, 0.5f, -0.5f, // 16: top-left
            -0.5f, -0.5f, -0.5f, // 17: bottom-left
            -0.5f, -0.5f, 0.5f, // 18: bottom-right
            -0.5f, 0.5f, 0.5f, // 19: top-right

            // Right face
            0.5f, 0.5f, 0.5f, // 20: top-left
            0.5f, -0.5f, 0.5f, // 21: bottom-left
            0.5f, -0.5f, -0.5f, // 22: bottom-right
            0.5f, 0.5f, -0.5f // 23: top-right
    };

    private static final int[] INDICES = new int[] {
            // Front face
            0, 1, 2, 0, 2, 3,
            // Back face
            4, 5, 6, 4, 6, 7,
            // Top face
            8, 9, 10, 8, 10, 11,
            // Bottom face
            12, 13, 14, 12, 14, 15,
            // Left face
            16, 17, 18, 16, 18, 19,
            // Right face
            20, 21, 22, 20, 22, 23
    };

    static {
        modelMap = new HashMap<>();
        entityMap = new HashMap<>();
    }

    public Scene(int width, int height) {
        projection = new Projection(width, height);
        camera = new Camera();
        textureCacheAtlas = new TextureCacheAtlas("textures/atlas.png", 256, 16);
    }

    public static void addEntity(Entity entity) {
        String modelId = entity.getModelId();
        Model model = modelMap.get(modelId);
        if (model == null) {
            throw new RuntimeException("Modello non trovato: " + modelId);
        }
        model.getEntitiesList().add(entity);
        entityMap.put(entity.getId(), entity);
    }

    public static void addModel(Model model) {
        modelMap.put(model.getId(), model);
    }

    public void cleanup() {
        // Qui puoi liberare risorse se necessario, ad esempio chiamando cleanup() su
        // textureCacheAtlas, modelMap, ecc.
        modelMap.clear();
        entityMap.clear();
    }

    public Map<String, Model> getModelMap() {
        return modelMap;
    }

    public Projection getProjection() {
        return projection;
    }

    public void resize(int width, int height) {
        projection.updateProjMatrix(width, height);
    }

    public Camera getCamera() {
        return camera;
    }

    public static Entity createEntity(BlockType type) {
        String modelId = "block-model-" + type.name().toLowerCase();
        String entityId = "block-entity-" + type.name().toLowerCase() + "-" + System.currentTimeMillis();

        Model blockModel = modelMap.get(modelId);
        if (blockModel == null) {
            // Ottieni la regione di texture per questo tipo di blocco
            Vector4f textureRegion = textureCacheAtlas.getTextureRegion(type);
            // Genera le coordinate UV usando la regione (48 valori per 6 facce)
            float[] textCoords = generateUVCoordinates(textureRegion);
            Mesh mesh = new Mesh(POSITIONS, textCoords, INDICES);
            blockModel = new Model(modelId, List.of(mesh));
            addModel(blockModel);
        }

        Entity blockEntity = new Entity(entityId, blockModel.getId(), textureCacheAtlas.getTextureRegion(type));
        addEntity(blockEntity);
        return blockEntity;
    }

    /**
     * Cleanup di un chunk: per ogni blocco del chunk, se esiste un entity
     * associato, lo rimuove.
     */
    public void cleanupChunk(Chunk chunk) {
        Block[][][] blocks = chunk.getBlocks();
        for (int x = 0; x < blocks.length; x++) {
            for (int y = 0; y < blocks[x].length; y++) {
                for (int z = 0; z < blocks[x][y].length; z++) {
                    Block block = blocks[x][y][z];
                    if (block != null && block.getEntity() != null) {
                        removeEntity(block.getEntity().getId());
                    }
                }
            }
        }
    }

    /**
     * Aggiorna la generazione del mondo (chunk loading/unloading) in base alla
     * posizione del giocatore.
     */
    public void updateWorldGeneration(float playerX, float playerZ) {
        Map<ChunkPosition, Chunk> loadedChunks = world.getLoadedChunks();
        int renderDistance = world.getRenderDistance();

        int centerChunkX = (int) Math.floor(playerX / (Chunk.WIDTH * Block.BLOCK_SIZE));
        int centerChunkZ = (int) Math.floor(playerZ / (Chunk.DEPTH * Block.BLOCK_SIZE));

        // Raccogli i chunk da rimuovere
        Set<ChunkPosition> chunksToRemove = new HashSet<>();
        for (Map.Entry<ChunkPosition, Chunk> entry : loadedChunks.entrySet()) {
            ChunkPosition chunkPos = entry.getKey();
            int chunkDistanceX = Math.abs(chunkPos.getX() - centerChunkX);
            int chunkDistanceZ = Math.abs(chunkPos.getZ() - centerChunkZ);
            if (chunkDistanceX > renderDistance || chunkDistanceZ > renderDistance) {
                chunksToRemove.add(chunkPos);
            }
        }
        // Per ogni chunk da rimuovere, esegui il cleanup e poi rimuovilo dalla mappa
        for (ChunkPosition posToRemove : chunksToRemove) {
            Chunk chunkToRemove = loadedChunks.get(posToRemove);
            if (chunkToRemove != null) {
                cleanupChunk(chunkToRemove);
            }
            loadedChunks.remove(posToRemove);
        }
        // Aggiungi i chunk mancanti intorno al centro
        for (int dx = -renderDistance; dx <= renderDistance; dx++) {
            for (int dz = -renderDistance; dz <= renderDistance; dz++) {
                int chunkX = centerChunkX + dx;
                int chunkZ = centerChunkZ + dz;
                ChunkPosition chunkPos = new ChunkPosition(chunkX, chunkZ);
                if (!loadedChunks.containsKey(chunkPos)) {
                    Chunk chunk = new Chunk(chunkX, chunkZ);
                    loadedChunks.put(chunkPos, chunk);
                }
            }
        }
    }

    /**
     * Genera le coordinate UV per 6 facce (48 valori) a partire da una regione.
     */
    private static float[] generateUVCoordinates(Vector4f region) {
        float[] textCoords = new float[6 * 4 * 2];
        for (int face = 0; face < 6; face++) {
            int offset = face * 8;
            textCoords[offset] = region.x; // top-left U
            textCoords[offset + 1] = region.y; // top-left V

            textCoords[offset + 2] = region.x; // bottom-left U
            textCoords[offset + 3] = region.w; // bottom-left V

            textCoords[offset + 4] = region.z; // bottom-right U
            textCoords[offset + 5] = region.w; // bottom-right V

            textCoords[offset + 6] = region.z; // top-right U
            textCoords[offset + 7] = region.y; // top-right V
        }
        return textCoords;
    }

    public World getWorld() {
        return world;
    }

    public void setWorld(World worldd) {
        world = worldd;
    }

    public TextureCacheAtlas getTextureCacheAtlas() {
        return textureCacheAtlas;
    }

    /**
     * Rimozione ottimizzata di un entity:
     * - Si usa la mappa globale per accedere direttamente all'entity.
     * - Nel modello, si esegue uno swap con l'ultimo elemento e si rimuove in O(1).
     */
    public void removeEntity(String entityId) {
        Entity entity = entityMap.remove(entityId);
        if (entity == null)
            return;
        Model model = modelMap.get(entity.getModelId());
        if (model != null) {
            List<Entity> list = model.getEntitiesList();
            int index = list.indexOf(entity);
            if (index != -1) {
                int last = list.size() - 1;
                list.set(index, list.get(last));
                list.remove(last);
            }
        }
    }
}package scene;

import org.joml.Matrix4f;
import org.joml.Vector3f;

public class Frustum {
    private Plane[] planes; // 6 piani che formano il frustum

    public Frustum() {
        planes = new Plane[6];
        for (int i = 0; i < 6; i++) {
            planes[i] = new Plane();
        }
    }

    /**
     * Aggiorna i piani del frustum combinando le matrici view e projection.
     */
    public void update(Matrix4f viewMatrix, Matrix4f projMatrix) {
        Matrix4f clipMatrix = new Matrix4f();
        projMatrix.mul(viewMatrix, clipMatrix);

        // Estrai il piano sinistro
        planes[0].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 0),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 0),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 0),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 0));
        planes[0].normalize();

        // Estrai il piano destro
        planes[1].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 0),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 0),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 0),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 0));
        planes[1].normalize();

        // Estrai il piano inferiore
        planes[2].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 1),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 1),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 1),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 1));
        planes[2].normalize();

        // Estrai il piano superiore
        planes[3].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 1),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 1),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 1),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 1));
        planes[3].normalize();

        // Estrai il piano near
        planes[4].set(
                clipMatrix.get(0, 3) + clipMatrix.get(0, 2),
                clipMatrix.get(1, 3) + clipMatrix.get(1, 2),
                clipMatrix.get(2, 3) + clipMatrix.get(2, 2),
                clipMatrix.get(3, 3) + clipMatrix.get(3, 2));
        planes[4].normalize();

        // Estrai il piano far
        planes[5].set(
                clipMatrix.get(0, 3) - clipMatrix.get(0, 2),
                clipMatrix.get(1, 3) - clipMatrix.get(1, 2),
                clipMatrix.get(2, 3) - clipMatrix.get(2, 2),
                clipMatrix.get(3, 3) - clipMatrix.get(3, 2));
        planes[5].normalize();
    }

    /**
     * Ritorna true se l'AABB (definito da min e max) è almeno parzialmente
     * all'interno del frustum.
     */
    public boolean isBoxInFrustum(Vector3f min, Vector3f max) {
        for (Plane plane : planes) {
            if (plane.classifyBox(min, max) == Plane.OUTSIDE) {
                return false;
            }
        }
        return true;
    }
}package scene;

import org.joml.*;
import java.lang.Math;

public class Camera {

    private Vector3f direction;
    private Vector3f position;
    private Vector3f right;
    private Vector2f rotation;
    private Vector3f up;
    private Matrix4f viewMatrix;
    private Frustum frustum;

    public Camera() {
        direction = new Vector3f();
        right = new Vector3f();
        up = new Vector3f();
        position = new Vector3f();
        viewMatrix = new Matrix4f();
        rotation = new Vector2f();

    }

    public void addRotation(float x, float y) {
        // Aggiorna yaw e pitch
        rotation.y += x; // Yaw (orizzontale)
        rotation.x += y; // Pitch (verticale)

        // Limita il pitch per evitare capovolgimenti (es. -89° e +89° in radianti)
        float pitchLimit = (float) Math.toRadians(89.0f);
        if (rotation.x > pitchLimit) {
            rotation.x = pitchLimit;
        } else if (rotation.x < -pitchLimit) {
            rotation.x = -pitchLimit;
        }

        recalculate();
    }

    public Vector3f getPosition() {
        return position;
    }

    public Matrix4f getViewMatrix() {
        return viewMatrix;
    }

    public void moveBackwards(float inc) {
        viewMatrix.positiveZ(direction).negate().mul(inc);
        position.sub(direction);
        recalculate();
    }

    public void moveDown(float inc) {
        viewMatrix.positiveY(up).mul(inc);
        position.sub(up);
        recalculate();
    }

    public void moveForward(float inc) {
        viewMatrix.positiveZ(direction).negate().mul(inc);
        position.add(direction);
        recalculate();
    }

    public void moveLeft(float inc) {
        viewMatrix.positiveX(right).mul(inc);
        position.sub(right);
        recalculate();
    }

    public void moveRight(float inc) {
        viewMatrix.positiveX(right).mul(inc);
        position.add(right);
        recalculate();
    }

    public void moveUp(float inc) {
        viewMatrix.positiveY(up).mul(inc);
        position.add(up);
        recalculate();
    }

    private void recalculate() {
        viewMatrix.identity()
                .rotateX(rotation.x)
                .rotateY(rotation.y)
                .translate(-position.x, -position.y, -position.z);
    }

    public void setPosition(float x, float y, float z) {
        position.set(x, y, z);
        recalculate();
    }

    public void setRotation(float x, float y) {
        rotation.set(x, y);
        recalculate();
    }

    public Frustum getFrustum() {
        // Calcola o aggiorna il frustum se necessario
        if (frustum == null) {
            frustum = new Frustum();
        }
        // Aggiorna il frustum in base alla posizione e orientamento della camera
        // frustum.update(getViewMatrix(), projecgetProjectionMatrix());
        return frustum;
    }
}
package scene;

import org.joml.*;

public class Entity {

    private final String id;
    private final String modelId;
    private Matrix4f modelMatrix;
    private Vector4f textureRegion;
    private Vector3f position;
    private Quaternionf rotation;
    private float scale;

    public Entity(String id, String modelId, Vector4f textureRegion) {
        this.id = id;
        this.modelId = modelId;
        this.textureRegion = textureRegion;
        modelMatrix = new Matrix4f();
        position = new Vector3f();
        rotation = new Quaternionf();
        scale = 1;
    }

    public String getId() {
        return id;
    }

    public String getModelId() {
        return modelId;
    }

    public Matrix4f getModelMatrix() {
        return modelMatrix;
    }

    public Vector3f getPosition() {
        return position;
    }

    public Quaternionf getRotation() {
        return rotation;
    }

    public float getScale() {
        return scale;
    }

    public final void setPosition(float x, float y, float z) {
        position.x = x;
        position.y = y;
        position.z = z;
    }

    public void setRotation(float x, float y, float z, float angle) {
        this.rotation.fromAxisAngleRad(x, y, z, angle);
    }

    public void setScale(float scale) {
        this.scale = scale;
    }

    public void updateModelMatrix() {
        modelMatrix.translationRotateScale(position, rotation, scale);
    }

    public Vector4f getTextureRegion() {
        return textureRegion;
    }

    public void setTextureRegion(Vector4f textureRegion) {
        this.textureRegion = textureRegion;
    }
}package scene;

import org.joml.Vector3f;

public class Plane {
    public static final int OUTSIDE = -1;
    private float a, b, c, d;

    public void set(float a, float b, float c, float d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }

    public void normalize() {
        float mag = (float) Math.sqrt(a * a + b * b + c * c);
        a /= mag;
        b /= mag;
        c /= mag;
        d /= mag;
    }

    /**
     * Classifica un box (AABB) rispetto al piano.
     * Se il punto "più esterno" (in direzione del piano) è fuori, ritorna OUTSIDE.
     */
    public int classifyBox(Vector3f min, Vector3f max) {
        float px = (a >= 0) ? max.x : min.x;
        float py = (b >= 0) ? max.y : min.y;
        float pz = (c >= 0) ? max.z : min.z;
        if (a * px + b * py + c * pz + d < 0)
            return OUTSIDE;
        return 1; // INSIDE (o INTERSECT)
    }
}package graphics;

import java.util.HashMap;
import java.util.Map;

import org.joml.Vector4f;

import world.Block.BlockType;

public class TextureCacheAtlas {
    private TextureAtlas atlas;
    private Map<String, float[]> uvCache;
    private Map<String, int[]> texturePositions;
    private Map<BlockType, Vector4f> textureRegionCache;

    public TextureCacheAtlas(String texturePath, int atlasSize, int tileSize) {
        this.atlas = new TextureAtlas(texturePath, atlasSize, tileSize);
        this.uvCache = new HashMap<>();
        this.texturePositions = initializeTexturePositions();
        this.textureRegionCache = new HashMap<>();
    }

    // Questo metodo potrebbe essere spostato in un file di configurazione esterno
    // per rendere il codice più manutenibile
    private Map<String, int[]> initializeTexturePositions() {
        Map<String, int[]> positions = new HashMap<>();
        positions.put("grass_top", new int[] { 1, 0 });
        positions.put("grass_side", new int[] { 3, 0 });
        positions.put("dirt", new int[] { 2, 0 });
        positions.put("stone", new int[] { 0, 4 });
        positions.put("wood", new int[] { 4, 1 });
        positions.put("default", new int[] { 0, 0 });
        return positions;
    }

    public TextureAtlas getAtlasTexture() {
        return atlas;
    }

    public void cleanup() {
        atlas.cleanup();
        uvCache.clear();
        texturePositions.clear();
        textureRegionCache.clear();
    }

    public Vector4f getTextureRegion(BlockType type) {
        return textureRegionCache.computeIfAbsent(type, t -> {
            // Mappa il tipo di blocco al nome della texture
            String textureName = switch (t) {
                case GRASS -> "grass_top"; // Per impostazione predefinita usiamo la texture superiore
                case DIRT -> "dirt";
                case STONE -> "stone";
                case WOOD -> "wood";
                default -> "default";
            };

            if (!texturePositions.containsKey(textureName)) {
                System.err.println("Warning: Texture '" + textureName + "' not found in atlas. Using default.");
                textureName = "default";
            }

            int[] position = texturePositions.get(textureName);
            float[] baseUV = atlas.getUVCoordinates(position[0], position[1]);

            // Creiamo un Vector4f con le coordinate UV (uMin, vMin, uMax, vMax)
            return new Vector4f(baseUV[0], baseUV[1], baseUV[2], baseUV[3]);
        });
    }

    public float[] getUVCoordinates(String textureName) {
        if (!uvCache.containsKey(textureName)) {
            if (!texturePositions.containsKey(textureName)) {
                System.err.println("Warning: Texture '" + textureName + "' not found in atlas. Using default.");
                textureName = "default";
            }

            int[] position = texturePositions.get(textureName);
            float[] baseUV = atlas.getUVCoordinates(position[0], position[1]);

            // Convert the UV format
            float[] formattedUV = new float[8];
            formattedUV[0] = baseUV[0]; // Top-left U
            formattedUV[1] = baseUV[1]; // Top-left V
            formattedUV[2] = baseUV[0]; // Bottom-left U
            formattedUV[3] = baseUV[3]; // Bottom-left V
            formattedUV[4] = baseUV[2]; // Bottom-right U
            formattedUV[5] = baseUV[3]; // Bottom-right V
            formattedUV[6] = baseUV[2]; // Top-right U
            formattedUV[7] = baseUV[1]; // Top-right V

            uvCache.put(textureName, formattedUV);
        }

        return uvCache.get(textureName);
    }
}package graphics;

import org.lwjgl.opengl.GL30;

import utils.Utils;

import java.util.*;

import static org.lwjgl.opengl.GL30.*;

public class ShaderProgram {

    private final int programId;

    public ShaderProgram(List<ShaderModuleData> shaderModuleDataList) {
            programId = glCreateProgram();
            if (programId == 0) {
                throw new RuntimeException("Could not create Shader");
            }
    
            List<Integer> shaderModules = new ArrayList<>();
            shaderModuleDataList.forEach(s -> shaderModules.add(createShader(Utils.readFile(s.shaderFile), s.shaderType)));
    
            link(shaderModules);
        }

    public void bind() {
        glUseProgram(programId);
    }

    public void cleanup() {
        unbind();
        if (programId != 0) {
            glDeleteProgram(programId);
        }
    }

    protected int createShader(String shaderCode, int shaderType) {
        int shaderId = glCreateShader(shaderType);
        if (shaderId == 0) {
            throw new RuntimeException("Error creating shader. Type: " + shaderType);
        }

        glShaderSource(shaderId, shaderCode);
        glCompileShader(shaderId);

        if (glGetShaderi(shaderId, GL_COMPILE_STATUS) == 0) {
            throw new RuntimeException("Error compiling Shader code: " + glGetShaderInfoLog(shaderId, 1024));
        }

        glAttachShader(programId, shaderId);

        return shaderId;
    }

    public int getProgramId() {
        return programId;
    }

    private void link(List<Integer> shaderModules) {
        glLinkProgram(programId);
        if (glGetProgrami(programId, GL_LINK_STATUS) == 0) {
            throw new RuntimeException("Error linking Shader code: " + glGetProgramInfoLog(programId, 1024));
        }

        shaderModules.forEach(s -> glDetachShader(programId, s));
        shaderModules.forEach(GL30::glDeleteShader);
    }

    public void unbind() {
        glUseProgram(0);
    }

    public void validate() {
        glValidateProgram(programId);
        if (glGetProgrami(programId, GL_VALIDATE_STATUS) == 0) {
            throw new RuntimeException("Error validating Shader code: " + glGetProgramInfoLog(programId, 1024));
        }
    }

    public record ShaderModuleData(String shaderFile, int shaderType) {
    }
}
package graphics;

import org.joml.Matrix4f;
import org.joml.Vector4f;
import org.lwjgl.system.MemoryStack;

import java.util.*;

import static org.lwjgl.opengl.GL20.*;

public class UniformsMap {

    private int programId;
    private Map<String, Integer> uniforms;

    public UniformsMap(int programId) {
        this.programId = programId;
        uniforms = new HashMap<>();
    }

    public void createUniform(String uniformName) {
        int uniformLocation = glGetUniformLocation(programId, uniformName);
        if (uniformLocation < 0) {
            throw new RuntimeException("Could not find uniform [" + uniformName + "] in shader program [" +
                    programId + "]");
        }
        uniforms.put(uniformName, uniformLocation);
    }

    private int getUniformLocation(String uniformName) {
        Integer location = uniforms.get(uniformName);
        if (location == null) {
            throw new RuntimeException("Could not find uniform [" + uniformName + "]");
        }
        return location.intValue();
    }

    public void setUniform(String uniformName, int value) {
        glUniform1i(getUniformLocation(uniformName), value);
    }

    public void setUniform(String name, Vector4f value) {
        glUniform4f(getUniformLocation(name), value.x, value.y, value.z, value.w);
    }

    public void setUniform(String uniformName, Matrix4f value) {
        try (MemoryStack stack = MemoryStack.stackPush()) {
            glUniformMatrix4fv(getUniformLocation(uniformName), false, value.get(stack.mallocFloat(16)));
        }
    }
}package graphics;

import org.joml.Matrix4f;

public class Projection {

    private static final float FOV = (float) Math.toRadians(60.0f);
    private static final float Z_FAR = 1000.f;
    private static final float Z_NEAR = 0.01f;

    private Matrix4f projMatrix;

    public Projection(int width, int height) {
        projMatrix = new Matrix4f();
        updateProjMatrix(width, height);
    }

    public Matrix4f getProjMatrix() {
        return projMatrix;
    }

    public void updateProjMatrix(int width, int height) {
        projMatrix.setPerspective(FOV, (float) width / height, Z_NEAR, Z_FAR);
    }
}
package graphics;

import org.lwjgl.opengl.GL30;
import org.lwjgl.system.MemoryUtil;

import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.util.*;

import static org.lwjgl.opengl.GL11.GL_FLOAT;
import static org.lwjgl.opengl.GL15.GL_ARRAY_BUFFER;
import static org.lwjgl.opengl.GL15.GL_ELEMENT_ARRAY_BUFFER;
import static org.lwjgl.opengl.GL15.GL_STATIC_DRAW;
import static org.lwjgl.opengl.GL15.glBindBuffer;
import static org.lwjgl.opengl.GL15.glBufferData;
import static org.lwjgl.opengl.GL15.glGenBuffers;
import static org.lwjgl.opengl.GL20.glEnableVertexAttribArray;
import static org.lwjgl.opengl.GL20.glVertexAttribPointer;
import static org.lwjgl.opengl.GL30.*;

public class Mesh {

    private int numVertices;
    private int vaoId;
    private List<Integer> vboIdList;

    public Mesh(float[] positions, float[] textCoords, int[] indices) {
        numVertices = indices.length;
        vboIdList = new ArrayList<>();

        vaoId = glGenVertexArrays();
        glBindVertexArray(vaoId);

        // Positions VBO
        int vboId = glGenBuffers();
        vboIdList.add(vboId);
        FloatBuffer positionsBuffer = MemoryUtil.memCallocFloat(positions.length);
        positionsBuffer.put(0, positions);
        glBindBuffer(GL_ARRAY_BUFFER, vboId);
        glBufferData(GL_ARRAY_BUFFER, positionsBuffer, GL_STATIC_DRAW);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);

        // Texture coordinates VBO
        vboId = glGenBuffers();
        vboIdList.add(vboId);
        FloatBuffer textCoordsBuffer = MemoryUtil.memCallocFloat(textCoords.length);
        textCoordsBuffer.put(0, textCoords);
        glBindBuffer(GL_ARRAY_BUFFER, vboId);
        glBufferData(GL_ARRAY_BUFFER, textCoordsBuffer, GL_STATIC_DRAW);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 2, GL_FLOAT, false, 0, 0);

        // Index VBO
        vboId = glGenBuffers();
        vboIdList.add(vboId);
        IntBuffer indicesBuffer = MemoryUtil.memCallocInt(indices.length);
        indicesBuffer.put(0, indices);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vboId);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesBuffer, GL_STATIC_DRAW);

        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);

        MemoryUtil.memFree(positionsBuffer);
        MemoryUtil.memFree(textCoordsBuffer);
        MemoryUtil.memFree(indicesBuffer);
    }

    public void cleanup() {
        vboIdList.forEach(GL30::glDeleteBuffers);
        glDeleteVertexArrays(vaoId);
    }

    public int getNumVertices() {
        return numVertices;
    }

    public final int getVaoId() {
        return vaoId;
    }
}
package graphics;

import static org.lwjgl.opengl.GL11.GL_COLOR_BUFFER_BIT;
import static org.lwjgl.opengl.GL11.GL_DEPTH_BUFFER_BIT;
import static org.lwjgl.opengl.GL11.GL_DEPTH_TEST;
import static org.lwjgl.opengl.GL11.glClear;
import static org.lwjgl.opengl.GL11.glEnable;
import static org.lwjgl.opengl.GL11.glViewport;

import org.lwjgl.opengl.GL;

import core.Window;
import scene.Scene;
import scene.SceneRender;

public class Render {
    private SceneRender sceneRender;

    public Render() {
        GL.createCapabilities();
        // Nel codice di inizializzazione
        glEnable(GL_DEPTH_TEST);
        sceneRender = new SceneRender();
    }

    public void cleanup() {
        sceneRender.cleanup();
    }

    public void render(Window window, Scene scene) {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        //glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
        glViewport(0, 0, window.getWidth(), window.getHeight());
        sceneRender.render(window, scene);
    }
}
package graphics;

import org.lwjgl.BufferUtils;
import org.lwjgl.system.MemoryStack;
import core.Main;
import java.io.IOException;
import java.io.InputStream;
import java.nio.*;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL30.*;
import static org.lwjgl.stb.STBImage.*;

public class TextureAtlas {

    private int textureId;
    private int atlasSize;
    private int tileSize;
    private String texturePath;

    public TextureAtlas(String texturePath, int atlasSize, int tileSize) {
        this.texturePath = texturePath;
        this.atlasSize = atlasSize;
        this.tileSize = tileSize;

        try (MemoryStack stack = MemoryStack.stackPush()) {
            InputStream inputStream = Main.class.getClassLoader().getResourceAsStream(texturePath);
            if (inputStream == null) {
                throw new RuntimeException("Texture not found: " + texturePath);
            }

            ByteBuffer imageBuffer;
            try {
                byte[] imageBytes = inputStream.readAllBytes();
                imageBuffer = BufferUtils.createByteBuffer(imageBytes.length);
                imageBuffer.put(imageBytes);
                imageBuffer.flip();
            } catch (IOException e) {
                throw new RuntimeException("Failed to read texture: " + texturePath, e);
            }

            IntBuffer w = stack.mallocInt(1);
            IntBuffer h = stack.mallocInt(1);
            IntBuffer channels = stack.mallocInt(1);

            ByteBuffer buf = stbi_load_from_memory(imageBuffer, w, h, channels, 4);
            if (buf == null) {
                throw new RuntimeException("Failed to load texture: " + stbi_failure_reason());
            }

            int width = w.get();
            int height = h.get();

            generateTexture(width, height, buf);
            stbi_image_free(buf);
        }
    }

    public void bind() {
        glBindTexture(GL_TEXTURE_2D, textureId);
    }

    public void cleanup() {
        glDeleteTextures(textureId);
    }

    private void generateTexture(int width, int height, ByteBuffer buf) {
        textureId = glGenTextures();
        glBindTexture(GL_TEXTURE_2D, textureId);
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

        // Imposta il wrapping a CLAMP_TO_EDGE per evitare il bleeding dei pixel
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    // Applica un offset di mezzo pixel per evitare il campionamento dei bordi
    public float[] getUVCoordinates(int x, int y) {
        float halfPixel = 0.5f / atlasSize;
        float uMin = (x * tileSize + halfPixel) / atlasSize;
        float vMin = (y * tileSize + halfPixel) / atlasSize;
        float uMax = (((x + 1) * tileSize) - halfPixel) / atlasSize;
        float vMax = (((y + 1) * tileSize) - halfPixel) / atlasSize;
        return new float[] { uMin, vMin, uMax, vMax };
    }

    public String getTexturePath() {
        return texturePath;
    }
}package graphics;

import java.util.ArrayList;
import java.util.List;

import scene.Entity;

public class Model {

    private final String id;
    private List<Entity> entitiesList;
    private List<Mesh> meshList;

    public Model(String id, List<Mesh> meshList) {
        this.id = id;
        this.meshList = meshList;
        this.entitiesList = new ArrayList<>();
    }

    public List<Entity> getEntitiesList() {
        return entitiesList;
    }

    public String getId() {
        return id;
    }

    public void setEntitiesList(List<Entity> entitiesList) {
        this.entitiesList = entitiesList;
    }

    public List<Mesh> getMeshList() {
        return this.meshList;
    }

    public void setMeshList(List<Mesh> meshList) {
        this.meshList = meshList;
    }

}package entities;

public class Mob {
    
}
package entities;

public class Player {
    
}
package entities;

public class Entity {
    
}
